declare type ErrorWithResponse = Error & {
    response?: import("node-fetch").Response;
};
declare type TeemoApiProxy<TSpec extends EndpointsSpec> = {
    [TEndpoint in Exclude<keyof TSpec, "base">]: {
        [TMethod in keyof TSpec[TEndpoint]]: (region: ReqRoutes<TSpec[TEndpoint][TMethod]>, ...kwargs: ReqArgsTuple<TSpec[TEndpoint][TMethod]>) => ReqReturn<TSpec[TEndpoint][TMethod]>;
    };
} & {
    base: TeemoApi<TSpec>;
};
declare class TeemoApi<TSpec extends EndpointsSpec> {
    /** The config for this TeemoApi. */
    readonly config: Config<TSpec>;
    /** The requesters created by this TeemoApi, keyed uniquely per api key and region. */
    private readonly _requesters;
    static createRiotApi(apiKey: string | RiotApiKeys, distFactor?: number): TeemoApi<typeof RiotApiConfig.endpoints>;
    constructor(config: Config<TSpec>);
    proxy(): TeemoApiProxy<TSpec>;
    req<TEndpoint extends keyof TSpec, TMethod extends keyof TSpec[TEndpoint]>(endpoint: TEndpoint, method: TMethod, region: ReqRoutes<TSpec[TEndpoint][TMethod]>, ...[kwargs, ..._]: ReqArgsTuple<TSpec[TEndpoint][TMethod]>): ReqReturn<TSpec[TEndpoint][TMethod]>;
    reqInternal(rateLimitId: string, methodId: string, url: string, fetchConfig: import("node-fetch").RequestInit): unknown;
    setDistFactor(factor: number): void;
}
/** Regional routing values for `tftMatchV1`, `lorRankedV1`, and `AMERICAS` for league endpoints. */
declare enum RegionalRoute {
    /** Americas. */
    AMERICAS = 1,
    /** Asia. */
    ASIA = 2,
    /** Europe. */
    EUROPE = 3,
    /** South East Asia. Only usable with the LoR endpoints (just `lorRankedV1` for now). */
    SEA = 4
}
/** Platform routing values for LoL, TFT. */
declare enum PlatformRoute {
    /** Brazil. */
    BR1 = 16,
    /** Europe, Northeast. */
    EUN1 = 17,
    /** Europe, West. */
    EUW1 = 18,
    /** Japan. */
    JP1 = 19,
    /** Korea. */
    KR = 20,
    /** Latin America, North. */
    LA1 = 21,
    /** Latin America, South. */
    LA2 = 22,
    /** North America. */
    NA1 = 23,
    /** Oceana. */
    OC1 = 24,
    /** Rusia. */
    RU = 25,
    /** Turkey. */
    TR1 = 26,
    /** Public Bet Environment. Only usable with `lolStatusV3`. */
    PBE1 = 31
}
/** Valorant platform routing values. */
declare enum ValPlatformRoute {
    /** Asia Pacific. */
    AP = 64,
    /** Brazil. */
    BR = 65,
    /** Europe. */
    EU = 66,
    /** Korea. */
    KR = 67,
    /** Latin America. */
    LATAM = 68,
    /** North America. */
    NA = 69
}
/** Combined routing enum. */
declare const AnyRoute: {
    [x: number]: string;
    AP: ValPlatformRoute.AP;
    BR: ValPlatformRoute.BR;
    EU: ValPlatformRoute.EU;
    KR: ValPlatformRoute.KR;
    LATAM: ValPlatformRoute.LATAM;
    NA: ValPlatformRoute.NA;
    /**
     * Parse a ValPlatformRoute from a string, or throw if unparsable.
     * Case-insensitive. Only looks at the beginning two-letter prefix to
     * determine the PlatformRoute.
     * @param str String to parse.
     * @returns The parsed ValPlatformRoute.
     * @throws Error if `str` could not be parsed.
     */
    parse(str: string): ValPlatformRoute;
    BR1: PlatformRoute.BR1;
    EUN1: PlatformRoute.EUN1;
    EUW1: PlatformRoute.EUW1;
    JP1: PlatformRoute.JP1;
    LA1: PlatformRoute.LA1;
    LA2: PlatformRoute.LA2;
    NA1: PlatformRoute.NA1;
    OC1: PlatformRoute.OC1;
    RU: PlatformRoute.RU;
    TR1: PlatformRoute.TR1;
    PBE1: PlatformRoute.PBE1;
    /**
     * Converts a PlatformRoute to the corresponding RegionalRoute.
     * Useful for `tftMatchV1` endpoints which require a RegionalRoute, while
     * other TFT endpoints require a PlatformRoute.
     * @param route PlatformRoute to be converted.
     * @returns A RegionalRoute: `AMERICAS`, `ASIA`, or `EUROPE`. Will not
     * return `SEA`, which is only used by `lorRankedV1`.
     */
    toRegional(route: PlatformRoute): Exclude<RegionalRoute, RegionalRoute.SEA>;
    AMERICAS: RegionalRoute.AMERICAS;
    ASIA: RegionalRoute.ASIA;
    EUROPE: RegionalRoute.EUROPE;
    SEA: RegionalRoute.SEA;
};
/** Combined routing type. */
declare type AnyRoute = RegionalRoute | PlatformRoute | ValPlatformRoute;
/** RegionalRoute static utility functions. */
declare namespace RegionalRoute {
    /**
     * Parse a RegionalRoute from a string, or throw if unparsable.
     * Case-insensitive. Only looks at the beginning two-letter prefix to
     * determine the PlatformRoute.
     * @param str String to parse.
     * @param excludeSea (optional) if parsing SEA should result in an error.
     * @returns The parsed RegionalRoute.
     * @throws Error if `str` could not be parsed.
     */
    function parse(str: string, excludeSea?: false): RegionalRoute;
    function parse(str: string, excludeSea: true): Exclude<RegionalRoute, RegionalRoute.SEA>;
}
/** PlatformRoute static utility functions. */
declare namespace PlatformRoute {
    /**
     * Converts a PlatformRoute to the corresponding RegionalRoute.
     * Useful for `tftMatchV1` endpoints which require a RegionalRoute, while
     * other TFT endpoints require a PlatformRoute.
     * @param route PlatformRoute to be converted.
     * @returns A RegionalRoute: `AMERICAS`, `ASIA`, or `EUROPE`. Will not
     * return `SEA`, which is only used by `lorRankedV1`.
     */
    function toRegional(route: PlatformRoute): Exclude<RegionalRoute, RegionalRoute.SEA>;
    /**
     * Parse a PlatformRoute from a string, or throw if unparsable.
     * Case-insensitive. Only looks at the beginning two or three-letter
     * prefix to determine the PlatformRoute.
     * @param str String to parse.
     * @returns The parsed PlatformRoute.
     * @throws Error if `str` could not be parsed.
     */
    function parse(str: string): PlatformRoute;
}
/** ValPlatformRoute static utility functions. */
declare namespace ValPlatformRoute {
    /**
     * Parse a ValPlatformRoute from a string, or throw if unparsable.
     * Case-insensitive. Only looks at the beginning two-letter prefix to
     * determine the PlatformRoute.
     * @param str String to parse.
     * @returns The parsed ValPlatformRoute.
     * @throws Error if `str` could not be parsed.
     */
    function parse(str: string): ValPlatformRoute;
}
/** 32-bit integer (signed). */
declare type int = number;
/**
 * 64-bit integer (signed).
 * NOTE: Precision loss for numbers over Number.MAX_SAFE_INTEGER (~9
 * quadrilion).
 */
declare type long = number;
/** 32-bit single-precision float. */
declare type float = number;
/** 64-bit double-precision float. */
declare type double = number;
/** Header information for an application or method rate limit. */
interface RateLimitType {
    readonly name: string;
    readonly headerLimit: string;
    readonly headerCount: string;
}
/** Token bucket configuration parameters. */
interface TokenBucketConfig {
    readonly distFactor?: number;
    readonly bins?: number;
    readonly binFactor?: number;
    readonly overhead?: number;
}
/**
 * Default token bucket initialization parameters before rate limits are known.
 */
interface InitialTokenBucketConfig extends TokenBucketConfig {
    readonly timespan: number;
    readonly limit: number;
}
/** Dictionary of API keys including a 'default' key. */
interface ApiKeys {
    default: string;
    [apiKeyName: string]: string | undefined;
}
/** A configuration needed to instantiate a RiotApi. */
interface Config<TSpec extends EndpointsSpec = EndpointsSpec> {
    distFactor: number;
    retries: number;
    readonly apiKeys: ApiKeys;
    readonly origin: string;
    readonly maxConcurrent: number;
    readonly defaultBuckets: readonly InitialTokenBucketConfig[];
    readonly bucketsConfig: TokenBucketConfig;
    readonly rateLimitTypeApplication: RateLimitType;
    readonly rateLimitTypeMethod: RateLimitType;
    readonly headerRetryAfter: string;
    readonly headerLimitType: string;
    readonly endpoints: TSpec;
}
/** Listing of endpoints. */
declare type EndpointsSpec = {
    readonly [endpoint: string]: {
        readonly [method: string]: ReqSpec;
    };
};
/** Named query parameters. */
declare type NamedParams = {
    [argName: string]: unknown;
};
/** Ordered path parameters. */
declare type OrderedParams = {
    [argIdx: number]: unknown;
};
/**
 * ReqSpec with optional type parameters for annotating the input parameters
 * and return type.
 */
declare type ReqSpec<_TReturn = any, _TRoutes extends AnyRoute | string = any, _TPath extends OrderedParams | NamedParams = any, _TQuery extends NamedParams = any, _TBody = any> = {
    readonly path: string;
    readonly method?: import("node-fetch").RequestInit['method'];
    readonly apiKeyName?: string;
};
/** Utility type which extracts Promise<TReturn> from a ReqSpec. */
declare type ReqReturn<TReqSpec extends ReqSpec = ReqSpec> = TReqSpec extends ReqSpec<infer TReturn> ? Promise<TReturn> : Promise<unknown>;
/** Utility type which extracts a Region type union from a ReqSpec. */
declare type ReqRoutes<TReqSpec extends ReqSpec = ReqSpec> = (TReqSpec extends ReqSpec<unknown, infer TRoutes> ? TRoutes : AnyRoute) | string;
/**
 * Utility type which allows top-level list fields to be replaced by single
 * non-list values of the corresponding type.
 */
declare type AllowSingleItemLists<T> = {
    [K in keyof T]: T[K] extends Array<infer TItem> ? T[K] | TItem : T[K];
};
/**
 * Utility type which creates a { path, query, body } kwargs type from a
 * ReqSpec. Fields are made optional if they are not required.
 */
declare type ReqArgs<TReqSpec extends ReqSpec> = TReqSpec extends ReqSpec<unknown, AnyRoute | string, infer TPath, infer TQuery, infer TBody> ? (({} extends TPath ? {
    path?: TPath | null;
} : {
    path: TPath;
}) & ({} extends TQuery ? {
    query?: AllowSingleItemLists<TQuery> | null;
} : {
    query: AllowSingleItemLists<TQuery>;
}) & (undefined extends TBody ? {
    body?: TBody;
} : {
    body: TBody;
})) : {
    path?: OrderedParams | NamedParams | null;
    query?: NamedParams | null;
    body?: unknown | null;
};
/**
 * ReqArgs but as a tuple so optional paramters can be spread.
 * HACK: see https://github.com/microsoft/TypeScript/issues/29131
 */
declare type ReqArgsTuple<TReqSpec extends ReqSpec = ReqSpec> = {} extends ReqArgs<TReqSpec> ? [ReqArgs<TReqSpec>?] : [ReqArgs<TReqSpec>];
declare const RiotApiConfig: {
    readonly apiKeys: {
        readonly default: null;
    };
    readonly distFactor: 1;
    readonly retries: 3;
    readonly origin: "https://{}.api.riotgames.com";
    readonly defaultBuckets: readonly [{
        readonly timespan: 1000;
        readonly limit: 1;
        readonly bins: 1;
        readonly binFactor: 1;
        readonly overhead: 0;
    }];
    readonly rateLimitTypeApplication: {
        readonly name: "application";
        readonly headerLimit: "x-app-rate-limit";
        readonly headerCount: "x-app-rate-limit-count";
    };
    readonly rateLimitTypeMethod: {
        readonly name: "method";
        readonly headerLimit: "x-method-rate-limit";
        readonly headerCount: "x-method-rate-limit-count";
    };
    readonly maxConcurrent: 500;
    readonly headerLimitType: "x-rate-limit-type";
    readonly headerRetryAfter: "retry-after";
    readonly bucketsConfig: {};
    readonly endpoints: {
        readonly accountV1: {
            /**
             * Get account by puuid
             */
            readonly getByPuuid: ReqSpec<accountV1.AccountDto, AnyRoute, [string] | {
                puuid: string;
            }, {}, undefined>;
            /**
             * Get account by riot id
             */
            readonly getByRiotId: ReqSpec<accountV1.AccountDto | null, AnyRoute, [string, string] | {
                gameName: string;
                tagLine: string;
            }, {}, undefined>;
            /**
             * Get account by access token
             */
            readonly getByAccessToken: ReqSpec<accountV1.AccountDto, AnyRoute, {} | [], {}, undefined>;
            /**
             * Get active shard for a player
             */
            readonly getActiveShard: ReqSpec<accountV1.ActiveShardDto | null, AnyRoute, {
                game: "val" | "lor";
                puuid: string;
            } | ["val" | "lor", string], {}, undefined>;
        };
        readonly championMasteryV4: {
            /**
             * Get all champion mastery entries sorted by number of champion points descending,
             */
            readonly getAllChampionMasteries: ReqSpec<any[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedSummonerId: string;
            }, {}, undefined>;
            /**
             * Get a champion mastery by player ID and champion ID.
             */
            readonly getChampionMastery: ReqSpec<any, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                encryptedSummonerId: string;
                championId: long;
            } | [string, number], {}, undefined>;
            /**
             * Get a player's total champion mastery score, which is the sum of individual champion mastery levels.
             */
            readonly getChampionMasteryScore: ReqSpec<number, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedSummonerId: string;
            }, {}, undefined>;
        };
        readonly championV3: {
            /**
             * Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)
             */
            readonly getChampionInfo: ReqSpec<championV3.ChampionInfo, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
        };
        readonly clashV1: {
            /**
             * Get players by summoner ID.
             * ## Implementation Notes
             * This endpoint returns a list of active Clash players for a given summoner ID. If a summoner registers for multiple tournaments at the same time (e.g., Saturday and Sunday) then both registrations would appear in this list.
             */
            readonly getPlayersBySummoner: ReqSpec<clashV1.PlayerDto[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                summonerId: string;
            }, {}, undefined>;
            /**
             * Get team by ID.
             */
            readonly getTeamById: ReqSpec<clashV1.TeamDto | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                teamId: string;
            }, {}, undefined>;
            /**
             * Get all active or upcoming tournaments.
             */
            readonly getTournaments: ReqSpec<clashV1.TournamentDto[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
            /**
             * Get tournament by team ID.
             */
            readonly getTournamentByTeam: ReqSpec<clashV1.TournamentDto | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                teamId: string;
            }, {}, undefined>;
            /**
             * Get tournament by ID.
             */
            readonly getTournamentById: ReqSpec<clashV1.TournamentDto | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                tournamentId: int;
            } | [number], {}, undefined>;
        };
        readonly leagueExpV4: {
            /**
             * Get all the league entries.
             */
            readonly getLeagueEntries: ReqSpec<leagueExpV4.LeagueEntryDTO[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                queue: "RANKED_SOLO_5x5" | "RANKED_TFT" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT";
                tier: "CHALLENGER" | "GRANDMASTER" | "MASTER" | "DIAMOND" | "PLATINUM" | "GOLD" | "SILVER" | "BRONZE" | "IRON";
                division: "I" | "II" | "III" | "IV";
            } | ["RANKED_SOLO_5x5" | "RANKED_TFT" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT", "CHALLENGER" | "GRANDMASTER" | "MASTER" | "DIAMOND" | "PLATINUM" | "GOLD" | "SILVER" | "BRONZE" | "IRON", "I" | "II" | "III" | "IV"], {
                page?: number | null | undefined;
            }, undefined>;
        };
        readonly leagueV4: {
            /**
             * Get the challenger league for given queue.
             */
            readonly getChallengerLeague: ReqSpec<leagueV4.LeagueListDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                queue: "RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT";
            } | ["RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT"], {}, undefined>;
            /**
             * Get league entries in all queues for a given summoner ID.
             */
            readonly getLeagueEntriesForSummoner: ReqSpec<leagueV4.LeagueEntryDTO[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedSummonerId: string;
            }, {}, undefined>;
            /**
             * Get all the league entries.
             */
            readonly getLeagueEntries: ReqSpec<leagueV4.LeagueEntryDTO[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                queue: "RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT";
                tier: "DIAMOND" | "PLATINUM" | "GOLD" | "SILVER" | "BRONZE" | "IRON";
                division: "I" | "II" | "III" | "IV";
            } | ["RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT", "DIAMOND" | "PLATINUM" | "GOLD" | "SILVER" | "BRONZE" | "IRON", "I" | "II" | "III" | "IV"], {
                page?: number | null | undefined;
            }, undefined>;
            /**
             * Get the grandmaster league of a specific queue.
             */
            readonly getGrandmasterLeague: ReqSpec<leagueV4.LeagueListDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, ["RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT"] | {
                queue: "RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT";
            }, {}, undefined>;
            /**
             * Get league with given ID, including inactive entries.
             */
            readonly getLeagueById: ReqSpec<leagueV4.LeagueListDTO | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                leagueId: string;
            }, {}, undefined>;
            /**
             * Get the master league for given queue.
             */
            readonly getMasterLeague: ReqSpec<leagueV4.LeagueListDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, ["RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT"] | {
                queue: "RANKED_SOLO_5x5" | "RANKED_FLEX_SR" | "RANKED_FLEX_TT";
            }, {}, undefined>;
        };
        readonly lolStatusV3: {
            /**
             * Get League of Legends status for the given shard.
             * ## Rate Limit Notes
             * Requests to this API are not counted against the application Rate Limits.
             */
            readonly getShardData: ReqSpec<lolStatusV3.ShardStatus, PlatformRoute, {} | [], {}, undefined>;
        };
        readonly lolStatusV4: {
            /**
             * Get League of Legends status for the given platform.
             */
            readonly getPlatformData: ReqSpec<any, PlatformRoute, {} | [], {}, undefined>;
        };
        readonly lorDeckV1: {
            /**
             * Get a list of the calling user's decks.
             */
            readonly getDecks: ReqSpec<any[], RegionalRoute, {} | [], {}, undefined>;
            /**
             * Create a new deck for the calling user.
             */
            readonly createDeck: ReqSpec<string, RegionalRoute, {} | [], {}, any>;
        };
        readonly lorInventoryV1: {
            /**
             * Return a list of cards owned by the calling user.
             */
            readonly getCards: ReqSpec<any[], RegionalRoute, {} | [], {}, undefined>;
        };
        readonly lorMatchV1: {
            /**
             * Get a list of match ids by PUUID
             */
            readonly getMatchIdsByPUUID: ReqSpec<string[], RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE, [string] | {
                puuid: string;
            }, {}, undefined>;
            /**
             * Get match by id
             */
            readonly getMatch: ReqSpec<any, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE, [string] | {
                matchId: string;
            }, {}, undefined>;
        };
        readonly lorRankedV1: {
            /**
             * Get the players in Master tier.
             */
            readonly getLeaderboards: ReqSpec<lorRankedV1.LeaderboardDto, RegionalRoute, {} | [], {}, undefined>;
        };
        readonly lorStatusV1: {
            /**
             * Get Legends of Runeterra status for the given platform.
             */
            readonly getPlatformData: ReqSpec<any, RegionalRoute, {} | [], {}, undefined>;
        };
        readonly matchV4: {
            /**
             * Get match IDs by tournament code.
             */
            readonly getMatchIdsByTournamentCode: ReqSpec<number[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                tournamentCode: string;
            }, {}, undefined>;
            /**
             * Get match by match ID.
             */
            readonly getMatch: ReqSpec<matchV4.MatchDto | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [number] | {
                matchId: long;
            }, {}, undefined>;
            /**
             * Get match by match ID and tournament code.
             */
            readonly getMatchByTournamentCode: ReqSpec<matchV4.MatchDto, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                matchId: long;
                tournamentCode: string;
            } | [number, string], {}, undefined>;
            /**
             * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.
             * ## Implementation Notes
             * A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.
             *
             * If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
             *
             * If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
             */
            readonly getMatchlist: ReqSpec<matchV4.MatchlistDto | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedAccountId: string;
            }, {
                champion?: number[] | null | undefined;
                queue?: number[] | null | undefined;
                season?: number[] | null | undefined;
                endTime?: number | null | undefined;
                beginTime?: number | null | undefined;
                endIndex?: number | null | undefined;
                beginIndex?: number | null | undefined;
            }, undefined>;
            /**
             * Get match timeline by match ID.
             * ## Implementation Notes
             * Not all matches have timeline data.
             */
            readonly getMatchTimeline: ReqSpec<matchV4.MatchTimelineDto | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [number] | {
                matchId: long;
            }, {}, undefined>;
        };
        readonly matchV5: {
            /**
             * Get a list of match ids by puuid
             */
            readonly getMatchIdsByPUUID: ReqSpec<string[], RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE, [string] | {
                puuid: string;
            }, {
                start?: number | null | undefined;
                count?: number | null | undefined;
            }, undefined>;
            /**
             * Get a match by match id
             */
            readonly getMatch: ReqSpec<any, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE, [string] | {
                matchId: string;
            }, {}, undefined>;
            /**
             * Get a match timeline by match id
             */
            readonly getTimeline: ReqSpec<any, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE, [string] | {
                matchId: string;
            }, {}, undefined>;
        };
        readonly spectatorV4: {
            /**
             * Get current game information for the given summoner ID.
             */
            readonly getCurrentGameInfoBySummoner: ReqSpec<spectatorV4.CurrentGameInfo | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedSummonerId: string;
            }, {}, undefined>;
            /**
             * Get list of featured games.
             */
            readonly getFeaturedGames: ReqSpec<spectatorV4.FeaturedGames, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
        };
        readonly summonerV4: {
            /**
             * Get a summoner by account ID.
             */
            readonly getByAccountId: ReqSpec<summonerV4.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedAccountId: string;
            }, {}, undefined>;
            /**
             * Get a summoner by summoner name.
             */
            readonly getBySummonerName: ReqSpec<summonerV4.SummonerDTO | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                summonerName: string;
            }, {}, undefined>;
            /**
             * Get a summoner by PUUID.
             */
            readonly getByPUUID: ReqSpec<summonerV4.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedPUUID: string;
            }, {}, undefined>;
            /**
             * Get a summoner by access token.
             */
            readonly getByAccessToken: ReqSpec<summonerV4.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
            /**
             * Get a summoner by summoner ID.
             */
            readonly getBySummonerId: ReqSpec<summonerV4.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedSummonerId: string;
            }, {}, undefined>;
        };
        readonly tftLeagueV1: {
            /**
             * Get the challenger league.
             */
            readonly getChallengerLeague: ReqSpec<tftLeagueV1.LeagueListDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
            /**
             * Get league entries for a given summoner ID.
             */
            readonly getLeagueEntriesForSummoner: ReqSpec<tftLeagueV1.LeagueEntryDTO[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                summonerId: string;
            }, {}, undefined>;
            /**
             * Get all the league entries.
             */
            readonly getLeagueEntries: ReqSpec<tftLeagueV1.LeagueEntryDTO[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                tier: "DIAMOND" | "PLATINUM" | "GOLD" | "SILVER" | "BRONZE" | "IRON";
                division: "I" | "II" | "III" | "IV";
            } | ["DIAMOND" | "PLATINUM" | "GOLD" | "SILVER" | "BRONZE" | "IRON", "I" | "II" | "III" | "IV"], {
                page?: number | null | undefined;
            }, undefined>;
            /**
             * Get the grandmaster league.
             */
            readonly getGrandmasterLeague: ReqSpec<tftLeagueV1.LeagueListDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
            /**
             * Get league with given ID, including inactive entries.
             */
            readonly getLeagueById: ReqSpec<tftLeagueV1.LeagueListDTO | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                leagueId: string;
            }, {}, undefined>;
            /**
             * Get the master league.
             */
            readonly getMasterLeague: ReqSpec<tftLeagueV1.LeagueListDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
            /**
             * Get the top rated ladder for given queue
             */
            readonly getTopRatedLadder: ReqSpec<any[], PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {
                queue: "RANKED_TFT_TURBO";
            } | ["RANKED_TFT_TURBO"], {}, undefined>;
        };
        readonly tftMatchV1: {
            /**
             * Get a list of match ids by PUUID
             */
            readonly getMatchIdsByPUUID: ReqSpec<string[], RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE, [string] | {
                puuid: string;
            }, {
                count?: number | null | undefined;
            }, undefined>;
            /**
             * Get a match by match id
             */
            readonly getMatch: ReqSpec<tftMatchV1.MatchDto | null, RegionalRoute.AMERICAS | RegionalRoute.ASIA | RegionalRoute.EUROPE, [string] | {
                matchId: string;
            }, {}, undefined>;
        };
        readonly tftSummonerV1: {
            /**
             * Get a summoner by account ID.
             */
            readonly getByAccountId: ReqSpec<tftSummonerV1.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedAccountId: string;
            }, {}, undefined>;
            /**
             * Get a summoner by summoner name.
             */
            readonly getBySummonerName: ReqSpec<tftSummonerV1.SummonerDTO | null, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                summonerName: string;
            }, {}, undefined>;
            /**
             * Get a summoner by PUUID.
             */
            readonly getByPUUID: ReqSpec<tftSummonerV1.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedPUUID: string;
            }, {}, undefined>;
            /**
             * Get a summoner by access token.
             */
            readonly getByAccessToken: ReqSpec<tftSummonerV1.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, {} | [], {}, undefined>;
            /**
             * Get a summoner by summoner ID.
             */
            readonly getBySummonerId: ReqSpec<tftSummonerV1.SummonerDTO, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedSummonerId: string;
            }, {}, undefined>;
        };
        readonly thirdPartyCodeV4: {
            /**
             * Get third party code for a given summoner ID.
             */
            readonly getThirdPartyCodeBySummonerId: ReqSpec<string, PlatformRoute.BR1 | PlatformRoute.EUN1 | PlatformRoute.EUW1 | PlatformRoute.JP1 | PlatformRoute.KR | PlatformRoute.LA1 | PlatformRoute.LA2 | PlatformRoute.NA1 | PlatformRoute.OC1 | PlatformRoute.RU | PlatformRoute.TR1, [string] | {
                encryptedSummonerId: string;
            }, {}, undefined>;
        };
        readonly tournamentStubV4: {
            /**
             * Create a mock tournament code for the given tournament.
             */
            readonly createTournamentCode: ReqSpec<string[], RegionalRoute.AMERICAS, {} | [], {
                count?: number | null | undefined;
                tournamentId: long;
            }, tournamentStubV4.TournamentCodeParameters>;
            /**
             * Gets a mock list of lobby events by tournament code.
             */
            readonly getLobbyEventsByCode: ReqSpec<tournamentStubV4.LobbyEventDTOWrapper, RegionalRoute.AMERICAS, [string] | {
                tournamentCode: string;
            }, {}, undefined>;
            /**
             * Creates a mock tournament provider and returns its ID.
             * ## Implementation Notes
             * Providers will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
             */
            readonly registerProviderData: ReqSpec<number, RegionalRoute.AMERICAS, {} | [], {}, tournamentStubV4.ProviderRegistrationParameters>;
            /**
             * Creates a mock tournament and returns its ID.
             */
            readonly registerTournament: ReqSpec<number, RegionalRoute.AMERICAS, {} | [], {}, tournamentStubV4.TournamentRegistrationParameters>;
        };
        readonly tournamentV4: {
            /**
             * Create a tournament code for the given tournament.
             */
            readonly createTournamentCode: ReqSpec<string[], RegionalRoute.AMERICAS, {} | [], {
                count?: number | null | undefined;
                tournamentId: long;
            }, tournamentV4.TournamentCodeParameters>;
            /**
             * Returns the tournament code DTO associated with a tournament code string.
             */
            readonly getTournamentCode: ReqSpec<tournamentV4.TournamentCodeDTO, RegionalRoute.AMERICAS, [string] | {
                tournamentCode: string;
            }, {}, undefined>;
            /**
             * Update the pick type, map, spectator type, or allowed summoners for a code.
             */
            readonly updateCode: ReqSpec<void, RegionalRoute.AMERICAS, [string] | {
                tournamentCode: string;
            }, {}, tournamentV4.TournamentCodeUpdateParameters>;
            /**
             * Gets a list of lobby events by tournament code.
             */
            readonly getLobbyEventsByCode: ReqSpec<tournamentV4.LobbyEventDTOWrapper, RegionalRoute.AMERICAS, [string] | {
                tournamentCode: string;
            }, {}, undefined>;
            /**
             * Creates a tournament provider and returns its ID.
             * ## Implementation Notes
             * Providers will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
             */
            readonly registerProviderData: ReqSpec<number, RegionalRoute.AMERICAS, {} | [], {}, tournamentV4.ProviderRegistrationParameters>;
            /**
             * Creates a tournament and returns its ID.
             */
            readonly registerTournament: ReqSpec<number, RegionalRoute.AMERICAS, {} | [], {}, tournamentV4.TournamentRegistrationParameters>;
        };
        readonly valContentV1: {
            /**
             * Get content optionally filtered by locale
             */
            readonly getContent: ReqSpec<valContentV1.ContentDto, AnyRoute, {} | [], {
                locale?: string | null | undefined;
            }, undefined>;
        };
        readonly valMatchV1: {
            /**
             * Get match by id
             */
            readonly getMatch: ReqSpec<valMatchV1.MatchDto | null, AnyRoute, [string] | {
                matchId: string;
            }, {}, undefined>;
            /**
             * Get matchlist for games played by puuid
             */
            readonly getMatchlist: ReqSpec<valMatchV1.MatchlistDto, AnyRoute, [string] | {
                puuid: string;
            }, {}, undefined>;
            /**
             * Get recent matches
             * ## Implementation Notes
             * Returns a list of match ids that have completed in the last 10 minutes for live regions and 12 hours for the esports routing value. NA/LATAM/BR share a match history deployment. As such, recent matches will return a combined list of matches from those three regions. Requests are load balanced so you may see some inconsistencies as matches are added/removed from the list.
             */
            readonly getRecent: ReqSpec<any, AnyRoute, {
                queue: "competitive" | "unrated" | "spikerush" | "tournamentmode";
            } | ["competitive" | "unrated" | "spikerush" | "tournamentmode"], {}, undefined>;
        };
        readonly valRankedV1: {
            /**
             * Get leaderboard for the competitive queue
             */
            readonly getLeaderboard: ReqSpec<any, ValPlatformRoute, [string] | {
                actId: string;
            }, {
                size?: number | null | undefined;
                startIndex?: number | null | undefined;
            }, undefined>;
        };
        readonly valStatusV1: {
            /**
             * Get VALORANT status for the given platform.
             */
            readonly getPlatformData: ReqSpec<any, ValPlatformRoute, {} | [], {}, undefined>;
        };
    };
};
/** API key dictionary for RiotApi endpoints. "default" corresponds to League of Legends endpoints. */
interface RiotApiKeys {
    default: string;
    tft?: string;
    lor?: string;
    tournament?: string;
    [apiKeyName: string]: string | undefined;
}
declare namespace accountV1 {
    /**
     * AccountDto data object, automatically generated.
     */
    interface AccountDto {
        puuid: string;
        /** This field may be excluded if the account doesn't have a gameName */
        gameName?: string | null;
        /** This field may be excluded if the account doesn't have a tagLine */
        tagLine?: string | null;
    }
}
declare namespace accountV1 {
    /**
     * ActiveShardDto data object, automatically generated.
     */
    interface ActiveShardDto {
        puuid: string;
        game: string;
        activeShard: string;
    }
}
declare namespace championMasteryV4 {
    /**
     * ChampionMasteryDTO data object, automatically generated.
     * # Description
     * This object contains single Champion Mastery information for player and champion combination.
     */
    interface ChampionMasteryDTO {
        /** Number of points needed to achieve next level. Zero if player reached maximum champion level for this champion. */
        championPointsUntilNextLevel: long;
        /** Is chest granted for this champion or not in current season. */
        chestGranted: boolean;
        /** Champion ID for this entry. */
        championId: long;
        /** Last time this champion was played by this player - in Unix milliseconds time format. */
        lastPlayTime: long;
        /** Champion level for specified player and champion combination. */
        championLevel: int;
        /** Summoner ID for this entry. (Encrypted) */
        summonerId: string;
        /** Total number of champion points for this player and champion combination - they are used to determine championLevel. */
        championPoints: int;
        /** Number of points earned since current level has been achieved. */
        championPointsSinceLastLevel: long;
        /** The token earned for this champion to levelup. */
        tokensEarned: int;
    }
}
declare namespace championV3 {
    /**
     * ChampionInfo data object, automatically generated.
     */
    interface ChampionInfo {
        maxNewPlayerLevel: int;
        freeChampionIdsForNewPlayers: int[];
        freeChampionIds: int[];
    }
}
declare namespace clashV1 {
    /**
     * PlayerDto data object, automatically generated.
     */
    interface PlayerDto {
        summonerId: string;
        teamId: string;
        /** (Legal values:  UNSELECTED,  FILL,  TOP,  JUNGLE,  MIDDLE,  BOTTOM,  UTILITY) */
        position: "UNSELECTED" | "FILL" | "TOP" | "JUNGLE" | "MIDDLE" | "BOTTOM" | "UTILITY";
        /** (Legal values:  CAPTAIN,  MEMBER) */
        role: "CAPTAIN" | "MEMBER";
    }
}
declare namespace clashV1 {
    /**
     * TeamDto data object, automatically generated.
     */
    interface TeamDto {
        id: string;
        tournamentId: int;
        name: string;
        iconId: int;
        tier: int;
        /** Summoner ID of the team captain. */
        captain: string;
        abbreviation: string;
        /** Team members. */
        players: clashV1.PlayerDto[];
    }
}
declare namespace clashV1 {
    /**
     * TournamentDto data object, automatically generated.
     */
    interface TournamentDto {
        id: int;
        themeId: int;
        nameKey: string;
        nameKeySecondary: string;
        /** Tournament phase. */
        schedule: clashV1.TournamentPhaseDto[];
    }
}
declare namespace clashV1 {
    /**
     * TournamentPhaseDto data object, automatically generated.
     */
    interface TournamentPhaseDto {
        id: int;
        registrationTime: long;
        startTime: long;
        cancelled: boolean;
    }
}
declare namespace leagueExpV4 {
    /**
     * LeagueEntryDTO data object, automatically generated.
     */
    interface LeagueEntryDTO {
        leagueId: string;
        /** Player's summonerId (Encrypted) */
        summonerId: string;
        summonerName: string;
        queueType: string;
        tier: string;
        rank: string;
        leaguePoints: int;
        /** Winning team on Summoners Rift. First placement in Teamfight Tactics. */
        wins: int;
        /** Losing team on Summoners Rift. Second through eighth placement in Teamfight Tactics. */
        losses: int;
        hotStreak: boolean;
        veteran: boolean;
        freshBlood: boolean;
        inactive: boolean;
        miniSeries?: leagueExpV4.MiniSeriesDTO | null;
    }
}
declare namespace leagueExpV4 {
    /**
     * MiniSeriesDTO data object, automatically generated.
     */
    interface MiniSeriesDTO {
        losses: int;
        progress: string;
        target: int;
        wins: int;
    }
}
declare namespace leagueV4 {
    /**
     * LeagueListDTO data object, automatically generated.
     */
    interface LeagueListDTO {
        leagueId: string;
        entries: leagueV4.LeagueItemDTO[];
        tier: string;
        name: string;
        queue: string;
    }
}
declare namespace leagueV4 {
    /**
     * LeagueItemDTO data object, automatically generated.
     */
    interface LeagueItemDTO {
        freshBlood: boolean;
        /** Winning team on Summoners Rift. */
        wins: int;
        summonerName: string;
        miniSeries?: leagueV4.MiniSeriesDTO | null;
        inactive: boolean;
        veteran: boolean;
        hotStreak: boolean;
        rank: string;
        leaguePoints: int;
        /** Losing team on Summoners Rift. */
        losses: int;
        /** Player's encrypted summonerId. */
        summonerId: string;
    }
}
declare namespace leagueV4 {
    /**
     * MiniSeriesDTO data object, automatically generated.
     */
    interface MiniSeriesDTO {
        losses: int;
        progress: string;
        target: int;
        wins: int;
    }
}
declare namespace leagueV4 {
    /**
     * LeagueEntryDTO data object, automatically generated.
     */
    interface LeagueEntryDTO {
        leagueId: string;
        /** Player's encrypted summonerId. */
        summonerId: string;
        summonerName: string;
        queueType: string;
        tier: string;
        rank: string;
        leaguePoints: int;
        /** Winning team on Summoners Rift. */
        wins: int;
        /** Losing team on Summoners Rift. */
        losses: int;
        hotStreak: boolean;
        veteran: boolean;
        freshBlood: boolean;
        inactive: boolean;
        miniSeries?: leagueV4.MiniSeriesDTO | null;
    }
}
declare namespace lolStatusV3 {
    /**
     * ShardStatus data object, automatically generated.
     */
    interface ShardStatus {
        locales: string[];
        hostname: string;
        name: string;
        services: lolStatusV3.Service[];
        slug: string;
        region_tag: string;
    }
}
declare namespace lolStatusV3 {
    /**
     * Service data object, automatically generated.
     */
    interface Service {
        incidents: lolStatusV3.Incident[];
        name: string;
        slug: string;
        status: string;
    }
}
declare namespace lolStatusV3 {
    /**
     * Incident data object, automatically generated.
     */
    interface Incident {
        active: boolean;
        created_at: string;
        id: long;
        updates: lolStatusV3.Message[];
    }
}
declare namespace lolStatusV3 {
    /**
     * Message data object, automatically generated.
     */
    interface Message {
        severity: string;
        updated_at: string;
        author: string;
        translations: lolStatusV3.Translation[];
        created_at: string;
        id: string;
        content: string;
    }
}
declare namespace lolStatusV3 {
    /**
     * Translation data object, automatically generated.
     */
    interface Translation {
        locale: string;
        content: string;
        heading: string;
    }
}
declare namespace lorRankedV1 {
    /**
     * LeaderboardDto data object, automatically generated.
     */
    interface LeaderboardDto {
        /** A list of players in Master tier. */
        players: lorRankedV1.PlayerDto[];
    }
}
declare namespace lorRankedV1 {
    /**
     * PlayerDto data object, automatically generated.
     */
    interface PlayerDto {
        name: string;
        rank: int;
        /** League points. */
        lp: int;
    }
}
declare namespace matchV4 {
    /**
     * MatchDto data object, automatically generated.
     */
    interface MatchDto {
        gameId: long;
        /** Participant identity information. Participant identity information is purposefully excluded for custom games. */
        participantIdentities: matchV4.ParticipantIdentityDto[];
        /** Please refer to the Game Constants documentation. */
        queueId: int;
        /** Please refer to the Game Constants documentation. */
        gameType: string;
        /** Match duration in seconds. */
        gameDuration: long;
        /** Team information. */
        teams: matchV4.TeamStatsDto[];
        /** Platform where the match was played. */
        platformId: string;
        /** Designates the timestamp when champion select ended and the loading screen appeared, NOT when the game timer was at 0:00. */
        gameCreation: long;
        /** Please refer to the Game Constants documentation. */
        seasonId: int;
        /** The major.minor version typically indicates the patch the match was played on. */
        gameVersion: string;
        /** Please refer to the Game Constants documentation. */
        mapId: int;
        /** Please refer to the Game Constants documentation. */
        gameMode: string;
        /** Participant information. */
        participants: matchV4.ParticipantDto[];
    }
}
declare namespace matchV4 {
    /**
     * ParticipantIdentityDto data object, automatically generated.
     */
    interface ParticipantIdentityDto {
        participantId: int;
        /** Player information not included in the response for custom matches. Custom matches are considered private unless a tournament code was used to create the match. */
        player: matchV4.PlayerDto;
    }
}
declare namespace matchV4 {
    /**
     * PlayerDto data object, automatically generated.
     */
    interface PlayerDto {
        profileIcon: int;
        /** Player's original accountId. */
        accountId: string;
        matchHistoryUri: string;
        /** Player's current accountId when the match was played. */
        currentAccountId: string;
        /** Player's current platformId when the match was played. */
        currentPlatformId: string;
        summonerName: string;
        /** Player's summonerId (Encrypted) */
        summonerId?: string | null;
        /** Player's original platformId. */
        platformId: string;
    }
}
declare namespace matchV4 {
    /**
     * TeamStatsDto data object, automatically generated.
     */
    interface TeamStatsDto {
        /** Number of towers the team destroyed. */
        towerKills: int;
        /** Number of times the team killed Rift Herald. */
        riftHeraldKills: int;
        /** Flag indicating whether or not the team scored the first blood. */
        firstBlood: boolean;
        /** Number of inhibitors the team destroyed. */
        inhibitorKills: int;
        /** If match queueId has a draft, contains banned champion data, otherwise empty. */
        bans: matchV4.TeamBansDto[];
        /** Flag indicating whether or not the team scored the first Baron kill. */
        firstBaron: boolean;
        /** Flag indicating whether or not the team scored the first Dragon kill. */
        firstDragon: boolean;
        /** For Dominion matches, specifies the points the team had at game end. */
        dominionVictoryScore: int;
        /** Number of times the team killed Dragon. */
        dragonKills: int;
        /** Number of times the team killed Baron. */
        baronKills: int;
        /** Flag indicating whether or not the team destroyed the first inhibitor. */
        firstInhibitor: boolean;
        /** Flag indicating whether or not the team destroyed the first tower. */
        firstTower: boolean;
        /** Number of times the team killed Vilemaw. */
        vilemawKills: int;
        /** Flag indicating whether or not the team scored the first Rift Herald kill. */
        firstRiftHerald: boolean;
        /** 100 for blue side. 200 for red side. */
        teamId: int;
        /** String indicating whether or not the team won. There are only two values visibile in public match history.
             (Legal values:  Fail,  Win) */
        win?: "Fail" | "Win" | null;
    }
}
declare namespace matchV4 {
    /**
     * TeamBansDto data object, automatically generated.
     */
    interface TeamBansDto {
        /** Banned championId. */
        championId: int;
        /** Turn during which the champion was banned. */
        pickTurn: int;
    }
}
declare namespace matchV4 {
    /**
     * ParticipantDto data object, automatically generated.
     */
    interface ParticipantDto {
        participantId: int;
        championId: int;
        /** List of legacy Rune information. Not included for matches played with Runes Reforged. */
        runes?: matchV4.RuneDto[] | null;
        /** Participant statistics. */
        stats: matchV4.ParticipantStatsDto;
        /** 100 for blue side. 200 for red side. */
        teamId: int;
        /** Participant timeline data. */
        timeline: matchV4.ParticipantTimelineDto;
        /** First Summoner Spell id. */
        spell1Id: int;
        /** Second Summoner Spell id. */
        spell2Id: int;
        /** Highest ranked tier achieved for the previous season in a specific subset of queueIds, if any, otherwise null. Used to display border in game loading screen. Please refer to the Ranked Info documentation.
             (Legal values:  CHALLENGER,  MASTER,  DIAMOND,  PLATINUM,  GOLD,  SILVER,  BRONZE,  UNRANKED) */
        highestAchievedSeasonTier?: "CHALLENGER" | "MASTER" | "DIAMOND" | "PLATINUM" | "GOLD" | "SILVER" | "BRONZE" | "UNRANKED" | null;
        /** List of legacy Mastery information. Not included for matches played with Runes Reforged. */
        masteries?: matchV4.MasteryDto[] | null;
    }
}
declare namespace matchV4 {
    /**
     * RuneDto data object, automatically generated.
     */
    interface RuneDto {
        runeId: int;
        rank: int;
    }
}
declare namespace matchV4 {
    /**
     * ParticipantStatsDto data object, automatically generated.
     */
    interface ParticipantStatsDto {
        item0: int;
        item2: int;
        totalUnitsHealed: int;
        item1: int;
        largestMultiKill: int;
        goldEarned: int;
        firstInhibitorKill?: boolean | null;
        physicalDamageTaken: long;
        nodeNeutralizeAssist?: int | null;
        totalPlayerScore?: int | null;
        champLevel: int;
        damageDealtToObjectives: long;
        totalDamageTaken: long;
        neutralMinionsKilled: int;
        deaths: int;
        tripleKills: int;
        magicDamageDealtToChampions: long;
        wardsKilled: int;
        pentaKills: int;
        damageSelfMitigated: long;
        largestCriticalStrike: int;
        nodeNeutralize?: int | null;
        totalTimeCrowdControlDealt: int;
        firstTowerKill?: boolean | null;
        magicDamageDealt: long;
        totalScoreRank?: int | null;
        nodeCapture?: int | null;
        wardsPlaced?: int | null;
        totalDamageDealt: long;
        timeCCingOthers: long;
        magicalDamageTaken: long;
        largestKillingSpree: int;
        totalDamageDealtToChampions: long;
        physicalDamageDealtToChampions: long;
        neutralMinionsKilledTeamJungle: int;
        totalMinionsKilled: int;
        firstInhibitorAssist?: boolean | null;
        visionWardsBoughtInGame: int;
        objectivePlayerScore?: int | null;
        kills: int;
        firstTowerAssist?: boolean | null;
        combatPlayerScore?: int | null;
        inhibitorKills?: int | null;
        turretKills?: int | null;
        participantId: int;
        trueDamageTaken: long;
        firstBloodAssist?: boolean | null;
        nodeCaptureAssist?: int | null;
        assists: int;
        teamObjective?: int | null;
        altarsNeutralized?: int | null;
        goldSpent: int;
        damageDealtToTurrets: long;
        altarsCaptured?: int | null;
        win: boolean;
        totalHeal: long;
        unrealKills: int;
        visionScore?: long | null;
        physicalDamageDealt: long;
        firstBloodKill?: boolean | null;
        longestTimeSpentLiving: int;
        killingSprees: int;
        sightWardsBoughtInGame?: int | null;
        trueDamageDealtToChampions: long;
        neutralMinionsKilledEnemyJungle: int;
        doubleKills: int;
        trueDamageDealt: long;
        quadraKills: int;
        item4: int;
        item3: int;
        item6: int;
        item5: int;
        playerScore0?: int | null;
        playerScore1?: int | null;
        playerScore2?: int | null;
        playerScore3?: int | null;
        playerScore4?: int | null;
        playerScore5?: int | null;
        playerScore6?: int | null;
        playerScore7?: int | null;
        playerScore8?: int | null;
        playerScore9?: int | null;
        /** Primary path keystone rune. */
        perk0?: int | null;
        /** Post game rune stats. */
        perk0Var1?: int | null;
        /** Post game rune stats. */
        perk0Var2?: int | null;
        /** Post game rune stats. */
        perk0Var3?: int | null;
        /** Primary path rune. */
        perk1?: int | null;
        /** Post game rune stats. */
        perk1Var1?: int | null;
        /** Post game rune stats. */
        perk1Var2?: int | null;
        /** Post game rune stats. */
        perk1Var3?: int | null;
        /** Primary path rune. */
        perk2?: int | null;
        /** Post game rune stats. */
        perk2Var1?: int | null;
        /** Post game rune stats. */
        perk2Var2?: int | null;
        /** Post game rune stats. */
        perk2Var3?: int | null;
        /** Primary path rune. */
        perk3?: int | null;
        /** Post game rune stats. */
        perk3Var1?: int | null;
        /** Post game rune stats. */
        perk3Var2?: int | null;
        /** Post game rune stats. */
        perk3Var3?: int | null;
        /** Secondary path rune. */
        perk4?: int | null;
        /** Post game rune stats. */
        perk4Var1?: int | null;
        /** Post game rune stats. */
        perk4Var2?: int | null;
        /** Post game rune stats. */
        perk4Var3?: int | null;
        /** Secondary path rune. */
        perk5?: int | null;
        /** Post game rune stats. */
        perk5Var1?: int | null;
        /** Post game rune stats. */
        perk5Var2?: int | null;
        /** Post game rune stats. */
        perk5Var3?: int | null;
        /** Primary rune path */
        perkPrimaryStyle?: int | null;
        /** Secondary rune path */
        perkSubStyle?: int | null;
        /** First stat rune. */
        statPerk0?: int | null;
        /** Second stat rune. */
        statPerk1?: int | null;
        /** Third stat rune. */
        statPerk2?: int | null;
    }
}
declare namespace matchV4 {
    /**
     * ParticipantTimelineDto data object, automatically generated.
     */
    interface ParticipantTimelineDto {
        participantId?: int | null;
        /** Creep score difference versus the calculated lane opponent(s) for a specified period. */
        csDiffPerMinDeltas?: {
            [key: string]: double;
        } | null;
        /** Damage taken for a specified period. */
        damageTakenPerMinDeltas?: {
            [key: string]: double;
        } | null;
        /** Participant's calculated role.
             (Legal values:  DUO,  NONE,  SOLO,  DUO_CARRY,  DUO_SUPPORT) */
        role?: "DUO" | "NONE" | "SOLO" | "DUO_CARRY" | "DUO_SUPPORT" | null;
        /** Damage taken difference versus the calculated lane opponent(s) for a specified period. */
        damageTakenDiffPerMinDeltas?: {
            [key: string]: double;
        } | null;
        /** Experience change for a specified period. */
        xpPerMinDeltas?: {
            [key: string]: double;
        } | null;
        /** Experience difference versus the calculated lane opponent(s) for a specified period. */
        xpDiffPerMinDeltas?: {
            [key: string]: double;
        } | null;
        /** Participant's calculated lane. MID and BOT are legacy values.
             (Legal values:  MID,  MIDDLE,  TOP,  JUNGLE,  BOT,  BOTTOM) */
        lane?: "MID" | "MIDDLE" | "TOP" | "JUNGLE" | "BOT" | "BOTTOM" | null;
        /** Creeps for a specified period. */
        creepsPerMinDeltas?: {
            [key: string]: double;
        } | null;
        /** Gold for a specified period. */
        goldPerMinDeltas?: {
            [key: string]: double;
        } | null;
    }
}
declare namespace matchV4 {
    /**
     * MasteryDto data object, automatically generated.
     */
    interface MasteryDto {
        rank: int;
        masteryId: int;
    }
}
declare namespace matchV4 {
    /**
     * MatchlistDto data object, automatically generated.
     */
    interface MatchlistDto {
        startIndex: int;
        /** There is a known issue that this field doesn't correctly return the total number of games that match the parameters of the request. Please paginate using beginIndex until you reach the end of a player's matchlist. */
        totalGames: int;
        endIndex: int;
        matches: matchV4.MatchReferenceDto[];
    }
}
declare namespace matchV4 {
    /**
     * MatchReferenceDto data object, automatically generated.
     */
    interface MatchReferenceDto {
        gameId: long;
        role: string;
        season: int;
        platformId: string;
        champion: int;
        queue: int;
        lane: string;
        timestamp: long;
    }
}
declare namespace matchV4 {
    /**
     * MatchTimelineDto data object, automatically generated.
     */
    interface MatchTimelineDto {
        frames: matchV4.MatchFrameDto[];
        frameInterval: long;
    }
}
declare namespace matchV4 {
    /**
     * MatchFrameDto data object, automatically generated.
     */
    interface MatchFrameDto {
        participantFrames: {
            [key: string]: matchV4.MatchParticipantFrameDto;
        };
        events: matchV4.MatchEventDto[];
        timestamp: long;
    }
}
declare namespace matchV4 {
    /**
     * MatchParticipantFrameDto data object, automatically generated.
     */
    interface MatchParticipantFrameDto {
        participantId: int;
        minionsKilled: int;
        teamScore?: int | null;
        dominionScore?: int | null;
        totalGold: int;
        level: int;
        xp: int;
        currentGold: int;
        position?: matchV4.MatchPositionDto | null;
        jungleMinionsKilled: int;
    }
}
declare namespace matchV4 {
    /**
     * MatchPositionDto data object, automatically generated.
     */
    interface MatchPositionDto {
        x: int;
        y: int;
    }
}
declare namespace matchV4 {
    /**
     * MatchEventDto data object, automatically generated.
     */
    interface MatchEventDto {
        laneType?: string | null;
        skillSlot?: int | null;
        ascendedType?: string | null;
        creatorId?: int | null;
        afterId?: int | null;
        eventType?: string | null;
        /** (Legal values:  CHAMPION_KILL,  WARD_PLACED,  WARD_KILL,  BUILDING_KILL,  ELITE_MONSTER_KILL,  ITEM_PURCHASED,  ITEM_SOLD,  ITEM_DESTROYED,  ITEM_UNDO,  SKILL_LEVEL_UP,  ASCENDED_EVENT,  CAPTURE_POINT,  PORO_KING_SUMMON) */
        type: "CHAMPION_KILL" | "WARD_PLACED" | "WARD_KILL" | "BUILDING_KILL" | "ELITE_MONSTER_KILL" | "ITEM_PURCHASED" | "ITEM_SOLD" | "ITEM_DESTROYED" | "ITEM_UNDO" | "SKILL_LEVEL_UP" | "ASCENDED_EVENT" | "CAPTURE_POINT" | "PORO_KING_SUMMON";
        levelUpType?: string | null;
        wardType?: string | null;
        participantId?: int | null;
        towerType?: string | null;
        itemId?: int | null;
        beforeId?: int | null;
        pointCaptured?: string | null;
        monsterType?: string | null;
        monsterSubType?: string | null;
        teamId?: int | null;
        position?: matchV4.MatchPositionDto | null;
        killerId?: int | null;
        timestamp: long;
        assistingParticipantIds?: int[] | null;
        buildingType?: string | null;
        victimId?: int | null;
    }
}
declare namespace spectatorV4 {
    /**
     * CurrentGameInfo data object, automatically generated.
     */
    interface CurrentGameInfo {
        /** The ID of the game */
        gameId: long;
        /** The game type */
        gameType: string;
        /** The game start time represented in epoch milliseconds */
        gameStartTime: long;
        /** The ID of the map */
        mapId: long;
        /** The amount of time in seconds that has passed since the game started */
        gameLength: long;
        /** The ID of the platform on which the game is being played */
        platformId: string;
        /** The game mode */
        gameMode: string;
        /** Banned champion information */
        bannedChampions: spectatorV4.BannedChampion[];
        /** The queue type (queue types are documented on the Game Constants page) */
        gameQueueConfigId?: long | null;
        /** The observer information */
        observers: spectatorV4.Observer;
        /** The participant information */
        participants: spectatorV4.CurrentGameParticipant[];
    }
}
declare namespace spectatorV4 {
    /**
     * BannedChampion data object, automatically generated.
     */
    interface BannedChampion {
        /** The turn during which the champion was banned */
        pickTurn: int;
        /** The ID of the banned champion */
        championId: long;
        /** The ID of the team that banned the champion */
        teamId: long;
    }
}
declare namespace spectatorV4 {
    /**
     * Observer data object, automatically generated.
     */
    interface Observer {
        /** Key used to decrypt the spectator grid game data for playback */
        encryptionKey: string;
    }
}
declare namespace spectatorV4 {
    /**
     * CurrentGameParticipant data object, automatically generated.
     */
    interface CurrentGameParticipant {
        /** The ID of the champion played by this participant */
        championId: long;
        /** Perks/Runes Reforged Information */
        perks: spectatorV4.Perks;
        /** The ID of the profile icon used by this participant */
        profileIconId: long;
        /** Flag indicating whether or not this participant is a bot */
        bot: boolean;
        /** The team ID of this participant, indicating the participant's team */
        teamId: long;
        /** The summoner name of this participant */
        summonerName: string;
        /** The encrypted summoner ID of this participant */
        summonerId: string;
        /** The ID of the first summoner spell used by this participant */
        spell1Id: long;
        /** The ID of the second summoner spell used by this participant */
        spell2Id: long;
        /** List of Game Customizations */
        gameCustomizationObjects: spectatorV4.GameCustomizationObject[];
    }
}
declare namespace spectatorV4 {
    /**
     * Perks data object, automatically generated.
     */
    interface Perks {
        /** IDs of the perks/runes assigned. */
        perkIds: long[];
        /** Primary runes path */
        perkStyle: long;
        /** Secondary runes path */
        perkSubStyle: long;
    }
}
declare namespace spectatorV4 {
    /**
     * GameCustomizationObject data object, automatically generated.
     */
    interface GameCustomizationObject {
        /** Category identifier for Game Customization */
        category: string;
        /** Game Customization content */
        content: string;
    }
}
declare namespace spectatorV4 {
    /**
     * FeaturedGames data object, automatically generated.
     */
    interface FeaturedGames {
        /** The list of featured games */
        gameList: spectatorV4.FeaturedGameInfo[];
        /** The suggested interval to wait before requesting FeaturedGames again */
        clientRefreshInterval: long;
    }
}
declare namespace spectatorV4 {
    /**
     * FeaturedGameInfo data object, automatically generated.
     */
    interface FeaturedGameInfo {
        /** The game mode
             (Legal values:  CLASSIC,  ODIN,  ARAM,  TUTORIAL,  ONEFORALL,  ASCENSION,  FIRSTBLOOD,  KINGPORO) */
        gameMode: "CLASSIC" | "ODIN" | "ARAM" | "TUTORIAL" | "ONEFORALL" | "ASCENSION" | "FIRSTBLOOD" | "KINGPORO";
        /** The amount of time in seconds that has passed since the game started */
        gameLength: long;
        /** The ID of the map */
        mapId: long;
        /** The game type
             (Legal values:  CUSTOM_GAME,  MATCHED_GAME,  TUTORIAL_GAME) */
        gameType: "CUSTOM_GAME" | "MATCHED_GAME" | "TUTORIAL_GAME";
        /** Banned champion information */
        bannedChampions: spectatorV4.BannedChampion[];
        /** The ID of the game */
        gameId: long;
        /** The observer information */
        observers: spectatorV4.Observer;
        /** The queue type (queue types are documented on the Game Constants page) */
        gameQueueConfigId: long;
        /** The game start time represented in epoch milliseconds */
        gameStartTime: long;
        /** The participant information */
        participants: spectatorV4.Participant[];
        /** The ID of the platform on which the game is being played */
        platformId: string;
    }
}
declare namespace spectatorV4 {
    /**
     * Participant data object, automatically generated.
     */
    interface Participant {
        /** Flag indicating whether or not this participant is a bot */
        bot: boolean;
        /** The ID of the second summoner spell used by this participant */
        spell2Id: long;
        /** The ID of the profile icon used by this participant */
        profileIconId: long;
        /** The summoner name of this participant */
        summonerName: string;
        /** The ID of the champion played by this participant */
        championId: long;
        /** The team ID of this participant, indicating the participant's team */
        teamId: long;
        /** The ID of the first summoner spell used by this participant */
        spell1Id: long;
    }
}
declare namespace summonerV4 {
    /**
     * SummonerDTO data object, automatically generated.
     * # Description
     * represents a summoner
     */
    interface SummonerDTO {
        /** Encrypted account ID. Max length 56 characters. */
        accountId: string;
        /** ID of the summoner icon associated with the summoner. */
        profileIconId: int;
        /** Date summoner was last modified specified as epoch milliseconds. The following events will update this timestamp: summoner name change, summoner level change, or profile icon change. */
        revisionDate: long;
        /** Summoner name. */
        name: string;
        /** Encrypted summoner ID. Max length 63 characters. */
        id: string;
        /** Encrypted PUUID. Exact length of 78 characters. */
        puuid: string;
        /** Summoner level associated with the summoner. */
        summonerLevel: long;
    }
}
declare namespace tftLeagueV1 {
    /**
     * LeagueListDTO data object, automatically generated.
     */
    interface LeagueListDTO {
        leagueId: string;
        entries: tftLeagueV1.LeagueItemDTO[];
        tier: string;
        name: string;
        queue: string;
    }
}
declare namespace tftLeagueV1 {
    /**
     * LeagueItemDTO data object, automatically generated.
     */
    interface LeagueItemDTO {
        freshBlood: boolean;
        /** First placement. */
        wins: int;
        summonerName: string;
        miniSeries?: tftLeagueV1.MiniSeriesDTO | null;
        inactive: boolean;
        veteran: boolean;
        hotStreak: boolean;
        rank: string;
        leaguePoints: int;
        /** Second through eighth placement. */
        losses: int;
        /** Player's encrypted summonerId. */
        summonerId: string;
    }
}
declare namespace tftLeagueV1 {
    /**
     * MiniSeriesDTO data object, automatically generated.
     */
    interface MiniSeriesDTO {
        losses: int;
        progress: string;
        target: int;
        wins: int;
    }
}
declare namespace tftLeagueV1 {
    /**
     * LeagueEntryDTO data object, automatically generated.
     */
    interface LeagueEntryDTO {
        leagueId: string;
        /** Player's encrypted summonerId. */
        summonerId: string;
        summonerName: string;
        queueType: string;
        tier: string;
        rank: string;
        leaguePoints: int;
        /** First placement. */
        wins: int;
        /** Second through eighth placement. */
        losses: int;
        hotStreak: boolean;
        veteran: boolean;
        freshBlood: boolean;
        inactive: boolean;
        miniSeries?: tftLeagueV1.MiniSeriesDTO | null;
    }
}
declare namespace tftMatchV1 {
    /**
     * MatchDto data object, automatically generated.
     */
    interface MatchDto {
        /** Match metadata. */
        metadata: tftMatchV1.MetadataDto;
        /** Match info. */
        info: tftMatchV1.InfoDto;
    }
}
declare namespace tftMatchV1 {
    /**
     * MetadataDto data object, automatically generated.
     */
    interface MetadataDto {
        /** Match data version. */
        data_version: string;
        /** Match id. */
        match_id: string;
        /** A list of encrypted participant PUUIDs. */
        participants: string[];
    }
}
declare namespace tftMatchV1 {
    /**
     * InfoDto data object, automatically generated.
     */
    interface InfoDto {
        /** Unix timestamp. */
        game_datetime: long;
        /** Game length in seconds. */
        game_length: float;
        /** Game variation key. Game variations documented in TFT static data. */
        game_variation?: string | null;
        /** Game client version. */
        game_version: string;
        /** Participants. */
        participants: tftMatchV1.ParticipantDto[];
        /** Please refer to the League of Legends documentation. */
        queue_id: int;
        /** Teamfight Tactics set number. */
        tft_set_number: int;
    }
}
declare namespace tftMatchV1 {
    /**
     * ParticipantDto data object, automatically generated.
     */
    interface ParticipantDto {
        /** Participant's companion. */
        companion: tftMatchV1.CompanionDto;
        /** Gold left after participant was eliminated. */
        gold_left: int;
        /** The round the participant was eliminated in. Note: If the player was eliminated in stage 2-1 their last_round would be 5. */
        last_round: int;
        /** Participant Little Legend level. Note: This is not the number of active units. */
        level: int;
        /** Participant placement upon elimination. */
        placement: int;
        /** Number of players the participant eliminated. */
        players_eliminated: int;
        /** Encrypted PUUID. */
        puuid: string;
        /** The number of seconds before the participant was eliminated. */
        time_eliminated: float;
        /** Damage the participant dealt to other players. */
        total_damage_to_players: int;
        /** A complete list of traits for the participant's active units. */
        traits: tftMatchV1.TraitDto[];
        /** A list of active units for the participant. */
        units: tftMatchV1.UnitDto[];
    }
}
declare namespace tftMatchV1 {
    /**
     * TraitDto data object, automatically generated.
     */
    interface TraitDto {
        /** Trait name. */
        name: string;
        /** Number of units with this trait. */
        num_units: int;
        /** Current style for this trait. (0 = No style, 1 = Bronze, 2 = Silver, 3 = Gold, 4 = Chromatic) */
        style?: int | null;
        /** Current active tier for the trait. */
        tier_current: int;
        /** Total tiers for the trait. */
        tier_total?: int | null;
    }
}
declare namespace tftMatchV1 {
    /**
     * UnitDto data object, automatically generated.
     */
    interface UnitDto {
        /** A list of the unit's items. Please refer to the Teamfight Tactics documentation for item ids. */
        items: int[];
        /** This field was introduced in patch 9.22 with data_version 2. */
        character_id: string;
        /** Unit name. */
        name: string;
        /** Unit rarity. This doesn't equate to the unit cost. */
        rarity: int;
        /** Unit tier. */
        tier: int;
    }
}
declare namespace tftMatchV1 {
    /**
     * CompanionDto data object, automatically generated.
     */
    interface CompanionDto {
        skin_ID: int;
        content_ID: string;
        species: string;
    }
}
declare namespace tftSummonerV1 {
    /**
     * SummonerDTO data object, automatically generated.
     * # Description
     * represents a summoner
     */
    interface SummonerDTO {
        /** Encrypted account ID. Max length 56 characters. */
        accountId: string;
        /** ID of the summoner icon associated with the summoner. */
        profileIconId: int;
        /** Date summoner was last modified specified as epoch milliseconds. The following events will update this timestamp: summoner name change, summoner level change, or profile icon change. */
        revisionDate: long;
        /** Summoner name. */
        name: string;
        /** Encrypted summoner ID. Max length 63 characters. */
        id: string;
        /** Encrypted PUUID. Exact length of 78 characters. */
        puuid: string;
        /** Summoner level associated with the summoner. */
        summonerLevel: long;
    }
}
declare namespace tournamentStubV4 {
    /**
     * TournamentCodeParameters data object, automatically generated.
     */
    interface TournamentCodeParameters {
        /** Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future. */
        allowedSummonerIds?: string[] | null;
        /** Optional string that may contain any data in any format, if specified at all. Used to denote any custom information about the game. */
        metadata?: string | null;
        /** The team size of the game. Valid values are 1-5. */
        teamSize: int;
        /** The pick type of the game.
             (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT) */
        pickType: "BLIND_PICK" | "DRAFT_MODE" | "ALL_RANDOM" | "TOURNAMENT_DRAFT";
        /** The map type of the game.
             (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS) */
        mapType: "SUMMONERS_RIFT" | "TWISTED_TREELINE" | "HOWLING_ABYSS";
        /** The spectator type of the game.
             (Legal values:  NONE,  LOBBYONLY,  ALL) */
        spectatorType: "NONE" | "LOBBYONLY" | "ALL";
    }
}
declare namespace tournamentStubV4 {
    /**
     * LobbyEventDTOWrapper data object, automatically generated.
     */
    interface LobbyEventDTOWrapper {
        eventList: tournamentStubV4.LobbyEventDTO[];
    }
}
declare namespace tournamentStubV4 {
    /**
     * LobbyEventDTO data object, automatically generated.
     */
    interface LobbyEventDTO {
        /** The summonerId that triggered the event (Encrypted) */
        summonerId: string;
        /** The type of event that was triggered */
        eventType: string;
        /** Timestamp from the event */
        timestamp: string;
    }
}
declare namespace tournamentStubV4 {
    /**
     * ProviderRegistrationParameters data object, automatically generated.
     */
    interface ProviderRegistrationParameters {
        /** The region in which the provider will be running tournaments.
             (Legal values:  BR,  EUNE,  EUW,  JP,  LAN,  LAS,  NA,  OCE,  PBE,  RU,  TR) */
        region: "BR" | "EUNE" | "EUW" | "JP" | "LAN" | "LAS" | "NA" | "OCE" | "PBE" | "RU" | "TR";
        /** The provider's callback URL to which tournament game results in this region should be posted. The URL must be well-formed, use the http or https protocol, and use the default port for the protocol (http URLs must use port 80, https URLs must use port 443). */
        url: string;
    }
}
declare namespace tournamentStubV4 {
    /**
     * TournamentRegistrationParameters data object, automatically generated.
     */
    interface TournamentRegistrationParameters {
        /** The provider ID to specify the regional registered provider data to associate this tournament. */
        providerId: int;
        /** The optional name of the tournament. */
        name?: string | null;
    }
}
declare namespace tournamentV4 {
    /**
     * TournamentCodeParameters data object, automatically generated.
     */
    interface TournamentCodeParameters {
        /** Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future. */
        allowedSummonerIds?: string[] | null;
        /** Optional string that may contain any data in any format, if specified at all. Used to denote any custom information about the game. */
        metadata?: string | null;
        /** The team size of the game. Valid values are 1-5. */
        teamSize: int;
        /** The pick type of the game.
             (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT) */
        pickType: "BLIND_PICK" | "DRAFT_MODE" | "ALL_RANDOM" | "TOURNAMENT_DRAFT";
        /** The map type of the game.
             (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS) */
        mapType: "SUMMONERS_RIFT" | "TWISTED_TREELINE" | "HOWLING_ABYSS";
        /** The spectator type of the game.
             (Legal values:  NONE,  LOBBYONLY,  ALL) */
        spectatorType: "NONE" | "LOBBYONLY" | "ALL";
    }
}
declare namespace tournamentV4 {
    /**
     * TournamentCodeDTO data object, automatically generated.
     */
    interface TournamentCodeDTO {
        /** The tournament code. */
        code: string;
        /** The spectator mode for the tournament code game. */
        spectators: string;
        /** The lobby name for the tournament code game. */
        lobbyName: string;
        /** The metadata for tournament code. */
        metaData: string;
        /** The password for the tournament code game. */
        password: string;
        /** The team size for the tournament code game. */
        teamSize: int;
        /** The provider's ID. */
        providerId: int;
        /** The pick mode for tournament code game. */
        pickType: string;
        /** The tournament's ID. */
        tournamentId: int;
        /** The tournament code's ID. */
        id: int;
        /** The tournament code's region.
             (Legal values:  BR,  EUNE,  EUW,  JP,  LAN,  LAS,  NA,  OCE,  PBE,  RU,  TR) */
        region: "BR" | "EUNE" | "EUW" | "JP" | "LAN" | "LAS" | "NA" | "OCE" | "PBE" | "RU" | "TR";
        /** The game map for the tournament code game */
        map: string;
        /** The summonerIds of the participants (Encrypted) */
        participants: string[];
    }
}
declare namespace tournamentV4 {
    /**
     * TournamentCodeUpdateParameters data object, automatically generated.
     */
    interface TournamentCodeUpdateParameters {
        /** Optional list of encrypted summonerIds in order to validate the players eligible to join the lobby. NOTE: We currently do not enforce participants at the team level, but rather the aggregate of teamOne and teamTwo. We may add the ability to enforce at the team level in the future. */
        allowedSummonerIds?: string[] | null;
        /** The pick type
             (Legal values:  BLIND_PICK,  DRAFT_MODE,  ALL_RANDOM,  TOURNAMENT_DRAFT) */
        pickType: "BLIND_PICK" | "DRAFT_MODE" | "ALL_RANDOM" | "TOURNAMENT_DRAFT";
        /** The map type
             (Legal values:  SUMMONERS_RIFT,  TWISTED_TREELINE,  HOWLING_ABYSS) */
        mapType: "SUMMONERS_RIFT" | "TWISTED_TREELINE" | "HOWLING_ABYSS";
        /** The spectator type
             (Legal values:  NONE,  LOBBYONLY,  ALL) */
        spectatorType: "NONE" | "LOBBYONLY" | "ALL";
    }
}
declare namespace tournamentV4 {
    /**
     * LobbyEventDTOWrapper data object, automatically generated.
     */
    interface LobbyEventDTOWrapper {
        eventList: tournamentV4.LobbyEventDTO[];
    }
}
declare namespace tournamentV4 {
    /**
     * LobbyEventDTO data object, automatically generated.
     */
    interface LobbyEventDTO {
        /** Timestamp from the event */
        timestamp: string;
        /** The type of event that was triggered */
        eventType: string;
        /** The summonerId that triggered the event (Encrypted) */
        summonerId: string;
    }
}
declare namespace tournamentV4 {
    /**
     * ProviderRegistrationParameters data object, automatically generated.
     */
    interface ProviderRegistrationParameters {
        /** The region in which the provider will be running tournaments.
             (Legal values:  BR,  EUNE,  EUW,  JP,  LAN,  LAS,  NA,  OCE,  PBE,  RU,  TR) */
        region: "BR" | "EUNE" | "EUW" | "JP" | "LAN" | "LAS" | "NA" | "OCE" | "PBE" | "RU" | "TR";
        /** The provider's callback URL to which tournament game results in this region should be posted. The URL must be well-formed, use the http or https protocol, and use the default port for the protocol (http URLs must use port 80, https URLs must use port 443). */
        url: string;
    }
}
declare namespace tournamentV4 {
    /**
     * TournamentRegistrationParameters data object, automatically generated.
     */
    interface TournamentRegistrationParameters {
        /** The provider ID to specify the regional registered provider data to associate this tournament. */
        providerId: int;
        /** The optional name of the tournament. */
        name?: string | null;
    }
}
declare namespace valContentV1 {
    /**
     * ContentDto data object, automatically generated.
     */
    interface ContentDto {
        version: string;
        characters: valContentV1.ContentItemDto[];
        maps: valContentV1.ContentItemDto[];
        chromas: valContentV1.ContentItemDto[];
        skins: valContentV1.ContentItemDto[];
        skinLevels: valContentV1.ContentItemDto[];
        equips: valContentV1.ContentItemDto[];
        gameModes: valContentV1.ContentItemDto[];
        sprays: valContentV1.ContentItemDto[];
        sprayLevels: valContentV1.ContentItemDto[];
        charms: valContentV1.ContentItemDto[];
        charmLevels: valContentV1.ContentItemDto[];
        playerCards: valContentV1.ContentItemDto[];
        playerTitles: valContentV1.ContentItemDto[];
    }
}
declare namespace valContentV1 {
    /**
     * ContentItemDto data object, automatically generated.
     */
    interface ContentItemDto {
        name: string;
        /** This field is excluded from the response when a locale is set */
        localizedNames?: valContentV1.LocalizedNamesDto | null;
        assetName: string;
    }
}
declare namespace valContentV1 {
    /**
     * LocalizedNamesDto data object, automatically generated.
     */
    interface LocalizedNamesDto {
        "ar-AE": string;
        "de-DE": string;
        "en-GB": string;
        "en-US": string;
        "es-ES": string;
        "es-MX": string;
        "fr-FR": string;
        "id-ID": string;
        "it-IT": string;
        "ja-JP": string;
        "ko-KR": string;
        "pl-PL": string;
        "pt-BR": string;
        "ru-RU": string;
        "th-TH": string;
        "tr-TR": string;
        "vi-VN": string;
        "zh-CN": string;
        "zh-TW": string;
    }
}
declare namespace valMatchV1 {
    /**
     * MatchDto data object, automatically generated.
     */
    interface MatchDto {
        matchInfo: valMatchV1.MatchInfoDto;
        players: valMatchV1.PlayerDto[];
        teams: valMatchV1.TeamDto[];
        roundResults: valMatchV1.RoundResultDto[];
    }
}
declare namespace valMatchV1 {
    /**
     * MatchInfoDto data object, automatically generated.
     */
    interface MatchInfoDto {
        matchId: string;
        mapId: string;
        gameLengthMillis: int;
        gameStartMillis: long;
        provisioningFlowId: string;
        isCompleted: boolean;
        customGameName: string;
        queueId: string;
        gameMode: string;
        isRanked: boolean;
        seasonId: string;
    }
}
declare namespace valMatchV1 {
    /**
     * PlayerDto data object, automatically generated.
     */
    interface PlayerDto {
        puuid: string;
        teamId: string;
        partyId: string;
        characterId: string;
        stats: valMatchV1.PlayerStatsDto;
        competitiveTier: int;
        playerCard: string;
        playerTitle: string;
    }
}
declare namespace valMatchV1 {
    /**
     * PlayerStatsDto data object, automatically generated.
     */
    interface PlayerStatsDto {
        score: int;
        roundsPlayed: int;
        kills: int;
        deaths: int;
        assists: int;
        playtimeMillis: int;
        abilityCasts: valMatchV1.AbilityCastsDto;
    }
}
declare namespace valMatchV1 {
    /**
     * AbilityCastsDto data object, automatically generated.
     */
    interface AbilityCastsDto {
        grenadeCasts: int;
        ability1Casts: int;
        ability2Casts: int;
        ultimateCasts: int;
    }
}
declare namespace valMatchV1 {
    /**
     * TeamDto data object, automatically generated.
     */
    interface TeamDto {
        /** This is an arbitrary string. Red and Blue in bomb modes. The puuid of the player in deathmatch. */
        teamId: string;
        won: boolean;
        roundsPlayed: int;
        roundsWon: int;
        /** Team points scored. Number of kills in deathmatch. */
        numPoints: int;
    }
}
declare namespace valMatchV1 {
    /**
     * RoundResultDto data object, automatically generated.
     */
    interface RoundResultDto {
        roundNum: int;
        roundResult: string;
        roundCeremony: string;
        winningTeam: string;
        /** PUUID of player */
        bombPlanter: string;
        /** PUUID of player */
        bombDefuser: string;
        plantRoundTime: int;
        plantPlayerLocations: valMatchV1.PlayerLocationsDto[];
        plantLocation: valMatchV1.LocationDto;
        plantSite: string;
        defuseRoundTime: int;
        defusePlayerLocations: valMatchV1.PlayerLocationsDto[];
        defuseLocation: valMatchV1.LocationDto;
        playerStats: valMatchV1.PlayerRoundStatsDto[];
        roundResultCode: string;
    }
}
declare namespace valMatchV1 {
    /**
     * PlayerLocationsDto data object, automatically generated.
     */
    interface PlayerLocationsDto {
        puuid: string;
        viewRadians: float;
        location: valMatchV1.LocationDto;
    }
}
declare namespace valMatchV1 {
    /**
     * LocationDto data object, automatically generated.
     */
    interface LocationDto {
        x: int;
        y: int;
    }
}
declare namespace valMatchV1 {
    /**
     * PlayerRoundStatsDto data object, automatically generated.
     */
    interface PlayerRoundStatsDto {
        puuid: string;
        kills: valMatchV1.KillDto[];
        damage: valMatchV1.DamageDto[];
        score: int;
        economy: valMatchV1.EconomyDto;
        ability: valMatchV1.AbilityDto;
    }
}
declare namespace valMatchV1 {
    /**
     * KillDto data object, automatically generated.
     */
    interface KillDto {
        gameTime?: int | null;
        roundTime?: int | null;
        timeSinceGameStartMillis?: int | null;
        timeSinceRoundStartMillis?: int | null;
        /** PUUID */
        killer: string;
        /** PUUID */
        victim: string;
        victimLocation: valMatchV1.LocationDto;
        /** List of PUUIDs */
        assistants: string[];
        playerLocations: valMatchV1.PlayerLocationsDto[];
        finishingDamage: valMatchV1.FinishingDamageDto;
    }
}
declare namespace valMatchV1 {
    /**
     * FinishingDamageDto data object, automatically generated.
     */
    interface FinishingDamageDto {
        damageType: string;
        damageItem: string;
        isSecondaryFireMode: boolean;
    }
}
declare namespace valMatchV1 {
    /**
     * DamageDto data object, automatically generated.
     */
    interface DamageDto {
        /** PUUID */
        receiver: string;
        damage: int;
        legshots: int;
        bodyshots: int;
        headshots: int;
    }
}
declare namespace valMatchV1 {
    /**
     * EconomyDto data object, automatically generated.
     */
    interface EconomyDto {
        loadoutValue: int;
        weapon: string;
        armor: string;
        remaining: int;
        spent: int;
    }
}
declare namespace valMatchV1 {
    /**
     * AbilityDto data object, automatically generated.
     */
    interface AbilityDto {
        grenadeEffects: string;
        ability1Effects: string;
        ability2Effects: string;
        ultimateEffects: string;
    }
}
declare namespace valMatchV1 {
    /**
     * MatchlistDto data object, automatically generated.
     */
    interface MatchlistDto {
        puuid: string;
        history: valMatchV1.MatchlistEntryDto[];
    }
}
declare namespace valMatchV1 {
    /**
     * MatchlistEntryDto data object, automatically generated.
     */
    interface MatchlistEntryDto {
        matchId: string;
        gameStartTimeMillis: long;
        teamId: string;
    }
}
