"use strict";
/**
 * URL class.
 * @internal
 */
const URL = global.URL
    || require("url").URL;
/**
 * Fetch api.
 * @internal
 */
const fetch = global.fetch || require("node-fetch");
/**
 * Returns a formatted string, replacing "{}", "{name}", or "{0}" with values
 * from the supplied `argObject`. `argObject` may be an object or Array.
 * @internal
 */
function format(format, argObject) {
    let i = 0;
    const result = format.replace(/\{(\w*)\}/g, (_, key) => {
        const val = key in argObject ? argObject[key] : argObject[i];
        if (undefined === val)
            throw new Error(`argObject provided for format "${format}" missing key ["${key}"] or index [${i}].`);
        i++;
        return val; // Will be converted to string.
    });
    return result;
}
/**
 * Non-cryptographic string hash, implemented as Java's String.hashCode().
 * @param str String to hash.
 * @internal
 */
function strHash(str) {
    return Array.from(str).reduce((hash, char) => 0 | (31 * hash + char.charCodeAt(0)), 0);
}
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Regional Requester. Handles `RateLimit`s for a region. One app limit and multiple method limits.
 * @internal
 */
class RegionalRequester {
    constructor(config) {
        this._config = config;
        this._appLimit = new RateLimit(this._config.rateLimitTypeApplication, 1, this._config);
        this._methodLimits = {};
        this._concurrentSema = new Semaphore(this._config.maxConcurrent);
    }
    req(methodId, url, fetchConfig) {
        // Get rate limits to obey.
        const rateLimits = [this._appLimit];
        if (this._config.rateLimitTypeMethod) // Also method limit if applicable.
            rateLimits.push(this._getMethodLimit(methodId));
        return (() => __awaiter(this, void 0, void 0, function* () {
            let response;
            let retries = 0;
            // Fetch retry loop.
            for (; retries < this._config.retries; retries++) {
                // Acquire concurrent request permit.
                // Note: This includes the time spent waiting for rate limits. To obey the rate limit we need to send the request
                //       immediately after delaying, otherwise the request could be delayed into a different bucket.
                yield this._concurrentSema.acquire();
                try {
                    // Wait for rate limits.
                    let delay;
                    while (0 <= (delay = RateLimit.getAllOrDelay(rateLimits)))
                        yield new Promise(resolve => setTimeout(resolve, delay));
                    // Send request, get response.
                    response = yield fetch(url, fetchConfig);
                    // Update if rate limits changed or 429 returned.
                    rateLimits.forEach(rl => rl.onResponse(response));
                    // Handle status codes.
                    if ([204, 404, 422].includes(response.status)) // Successful response, but no data found.
                        return null;
                    if (response.ok) // Successful response (presumably) with body.
                        return response.json(); // No `await` to release semaphore sooner.
                    if (429 === response.status || response.status >= 500) // Retryable responses.
                        continue;
                }
                finally {
                    // Release concurrent request permit.
                    // Note: This may be released before the full response body is read.
                    this._concurrentSema.release();
                }
            }
            // Request failed.
            const err = new Error(`Request failed after ${retries} retries with code ${response && response.status}. ` +
                "The 'response' field of this Error contains the failed Response for debugging or error handling.");
            err.response = response;
            throw err;
        }))();
    }
    updateDistFactor() {
        this._appLimit.setDistFactor(this._config.distFactor);
        Object.values(this._methodLimits).forEach(rl => rl.setDistFactor(this._config.distFactor));
    }
    // PRIVATE METHODS
    _getMethodLimit(methodId) {
        return this._methodLimits[methodId] ||
            (this._methodLimits[methodId] = new RateLimit(this._config.rateLimitTypeMethod, 1, this._config));
    }
}
/**
 * Rate limit. A collection of token buckets, updated when needed.
 * @internal
 */
class RateLimit {
    constructor(type, distFactor, config) {
        this._config = config;
        this._type = type;
        this._buckets = this._config.defaultBuckets.map(b => new TokenBucket(b.timespan, b.limit, b));
        this._retryAfter = 0;
        this._distFactor = distFactor;
    }
    /**
     * Get tokens for a single request from all the given rate limits or a delay to wait.
     * Returns -1 if tokens were obtained and the request can proceed, otherwise a positive value in milliseconds to
     * delay.
     */
    static getAllOrDelay(rateLimits) {
        const delay = rateLimits
            .map(r => r.retryDelay())
            .reduce((a, b, _idx, _arr) => Math.max(a, b), -1);
        if (0 <= delay)
            return delay; // Techincally the delay could be more but whatever.
        const allBuckets = [].concat(...rateLimits.map(rl => rl._buckets));
        return TokenBucket.getAllOrDelay(allBuckets);
    }
    retryDelay() {
        const now = Date.now();
        return now > this._retryAfter ? -1 : this._retryAfter - now;
    }
    onResponse(response) {
        // Handle 429 retry-after header (if exists).
        if (429 === response.status) {
            // const type = this._config.headerLimitType ? response.headers.get(this._config.headerLimitType) : this._config.defaultLimitType;
            const type = response.headers.get(this._config.headerLimitType);
            if (!type)
                throw new Error('Response missing type.');
            if (this._type.name === type.toLowerCase()) {
                const retryAfter = Number(response.headers.get(this._config.headerRetryAfter));
                if (Number.isNaN(retryAfter))
                    throw new Error('Response 429 missing retry-after header.'); // TODO?
                this._retryAfter = Date.now() + retryAfter * 1000 + 500;
            }
        }
        // Update rate limit from headers (if changed).
        const limitHeader = response.headers.get(this._type.headerLimit);
        const countHeader = response.headers.get(this._type.headerCount);
        if (limitHeader && countHeader && this._bucketsNeedUpdate(limitHeader))
            this._buckets = this._getBucketsFromHeaders(limitHeader, countHeader, this._config.bucketsConfig);
    }
    setDistFactor(factor) {
        this._distFactor = factor;
        this._buckets.forEach(b => b.setDistFactor(factor));
    }
    // PRIVATE METHODS
    _bucketsNeedUpdate(limitHeader) {
        const limits = this._buckets.map(b => b.toLimitString()).join(',');
        return limitHeader !== limits;
    }
    _getBucketsFromHeaders(limitHeader, countHeader, bucketsConfig = {}) {
        // Limits: "20000:10,1200000:600"
        // Counts: "7:10,58:600"
        const limits = limitHeader.split(',');
        const counts = countHeader.split(',');
        if (limits.length !== counts.length)
            throw new Error(`Limit and count headers do not match: ${limitHeader}, ${countHeader}.`);
        return limits
            .map((limit, i) => {
            const count = counts[i];
            // Spans are in seconds (not millis), so they must be multiplied by 1000.
            const [limitVal, limitSpan] = limit.split(':').map(Number);
            const [countVal, countSpan] = count.split(':').map(Number);
            if (limitSpan !== countSpan)
                throw new Error(`Limit span and count span do not match: ${limitSpan}, ${countSpan}.`);
            const bucket = new TokenBucket(1000 * limitSpan, limitVal, Object.assign({ distFactor: this._distFactor }, bucketsConfig));
            bucket.getTokens(countVal);
            return bucket;
        });
    }
}
/**
 * Default token bucket configuration.
 * @internal
 */
const TOKENBUCKETCONFIG_DEFAULT = {
    distFactor: 1,
    bins: 20,
    binFactor: 0.95,
    overhead: 20,
};
/**
 * Token bucket. Represents a single "100:60", AKA a 100 tokens per 60 seconds pair.
 * `bins`: Number of discrete bins to count into per timespan. `limit * binFactor` tokens alloted per bin.
 * `binFactor`: Value in range (0, 1], representing the fraction of `limit` requests allowed per bin.
 * `Overhead`: Time to extend `timespan` by in milliseconds. This is to prevent literal edge cases where requests can
 *     be counted into the wrong bucket, causing 429s.
 * `now`: Function which returns millisecond time.
 * `distFactor`: Value in range (0, 1] representing the fraction of the total rate limit this instance can use.
 * @internal
 */
class TokenBucket {
    constructor(timespan, limit, config = {}, now = Date.now) {
        const { distFactor, bins, binFactor, overhead } = Object.assign(Object.assign({}, TOKENBUCKETCONFIG_DEFAULT), config);
        if (binFactor <= 0 || 1 < binFactor)
            throw new Error(`binFactor ${binFactor} must be in range (0, 1].`);
        this._now = now;
        // Given values for checking equality when updating buckets.
        this._givenTimespan = timespan;
        this._givenLimit = limit;
        // Configuration values (rarely change).
        this._binFactor = binFactor;
        this._timespan = timespan + overhead;
        this._binTimespan = Math.ceil(this._timespan / bins); // Timespan per bin.
        // Fields that track requests, (change frequently).
        this._total = 0;
        this._time = -1;
        this._buffer = new Array(bins + 1).fill(0);
        this.setDistFactor(distFactor);
    }
    /**
     * Get one token from all the given token buckets or a delay to wait.
     * Returns -1 if tokens were obtained, otherwise a positive value in milliseconds to delay.
     */
    static getAllOrDelay(tokenBuckets) {
        const delay = tokenBuckets
            .map(b => b.getDelay())
            .reduce((a, b) => Math.max(a, b), -1);
        if (delay >= 0)
            return delay;
        tokenBuckets.forEach(b => b.getTokens(1));
        return -1;
    }
    setDistFactor(distFactor) {
        this._limit = this._givenLimit * distFactor;
        this._binLimit = Math.max(1, Math.floor(this._limit * this._binFactor));
    }
    /** Returns delay in milliseconds or -1 if token available. */
    getDelay() {
        const index = this._update();
        if (this._limit > this._total) {
            if (this._binLimit <= this._buffer[index])
                return this._getTimeToBucket(1);
            return -1;
        }
        // Check how soon into the future old buckets will be zeroed, making requests available.
        let i = 1;
        for (; this._buffer.length > i; i++) {
            if (0 < this._buffer[(index + i) % this._buffer.length])
                break;
        }
        return this._getTimeToBucket(i);
    }
    getTokens(n) {
        const index = this._update();
        this._buffer[index] += n;
        this._total += n;
        return this._total <= this._limit && this._buffer[index] <= this._binLimit;
    }
    toLimitString() {
        return `${this._givenLimit}:${this._givenTimespan / 1000}`;
    }
    // PRIVATE METHODS
    /**
     * Update the internal state for the current time.
     * Returns the index of the current buffer bin.
     */
    _update() {
        if (0 > this._time) {
            this._time = this._now();
            return this._getIndex(this._time);
        }
        let index = this._getIndex(this._time);
        const length = this._getLength(this._time, (this._time = this._now()));
        if (0 > length)
            throw new Error('Negative length.');
        if (0 === length)
            return index;
        if (this._buffer.length <= length) {
            this._buffer.fill(0);
            this._total = 0;
            return index;
        }
        for (let i = 0; length > i; i++) {
            index++;
            index %= this._buffer.length;
            this._total -= this._buffer[index];
            this._buffer[index] = 0;
        }
        if (this._getIndex(this._time) !== index)
            throw new Error(`Get index time wrong: ${this._getIndex(this._time)}, ${index}.`);
        return index;
    }
    /** Returns the index of the given epoch millisecond timestamp. */
    _getIndex(ts) {
        return Math.floor((ts / this._binTimespan) % this._buffer.length);
    }
    /** Returns the index difference of the two given epoch millisecond timestamps. */
    _getLength(start, end) {
        return Math.floor(end / this._binTimespan) - Math.floor(start / this._binTimespan);
    }
    /** Returns the time needed for N buckets to pass. */
    _getTimeToBucket(n) {
        return n * this._binTimespan - (this._time % this._binTimespan);
    }
}
/** @internal */
class Semaphore {
    constructor(count) {
        this._permits = count;
        this._queue = [];
    }
    acquire() {
        return new Promise((resolve) => {
            if (this._permits) {
                this._permits--;
                resolve();
            }
            else
                this._queue.push(resolve);
        });
    }
    release() {
        const resolve = this._queue.shift();
        (resolve ? resolve() : this._permits++);
    }
}
class TeemoApi {
    constructor(config) {
        this.config = config;
        this._requesters = {};
    }
    static createRiotApi(apiKey, distFactor = 1.0) {
        const apiKeys = 'string' === typeof apiKey ? { default: apiKey } : apiKey;
        if (!apiKeys.default)
            throw Error('apiKey argument to createRiotApi missing "default" key.');
        if (distFactor <= 0 || 1 < distFactor)
            throw Error(`Invalid distFactor: ${distFactor}, must be in range (0, 1].`);
        return new TeemoApi(Object.assign(Object.assign({}, RiotApiConfig), { distFactor,
            apiKeys }));
    }
    proxy() {
        return new Proxy(this, getApiProxyHandler());
    }
    req(endpoint, method, region, ...[kwargs, ..._]) {
        kwargs = kwargs || {};
        // Get spec.
        let ep;
        let sp;
        if ('object' !== typeof (ep = this.config.endpoints[endpoint]))
            throw Error(`Unknown endpoint "${endpoint}".\nAvailable endpoints: ${JSON.stringify(Object.keys(this.config.endpoints))}`);
        if ('string' !== typeof (sp = ep[method]).path)
            throw Error(`Unknown method "${method}" in endpoint "${endpoint}".\nAvailable methods: ${JSON.stringify(Object.keys(ep))}`);
        // Region string.
        const regionStr = 'number' === typeof region ? AnyRoute[region] : region;
        // Get API Key.
        const apiKey = sp.apiKeyName && this.config.apiKeys[sp.apiKeyName] || this.config.apiKeys.default;
        if (!apiKey)
            throw Error(`No valid API key found for name ${JSON.stringify(sp.apiKeyName)} or "default".`);
        // Build URL.
        const path = kwargs.path ? format(sp.path, kwargs.path) : sp.path;
        // QueryParams. First build URL.
        const url = new URL(path, format(this.config.origin, [regionStr]));
        // Then build URL query params.
        kwargs.query && Object.entries(kwargs.query).forEach(([key, vals]) => {
            if (!Array.isArray(vals)) // Not array.
                url.searchParams.set(key, vals);
            // else if (this.config.collapseQueryArrays) // Array, collapse.
            //     url.searchParams.set(key, vals.join(','));
            else // Array, do not collapse.
                vals.forEach(val => url.searchParams.append(key, val));
        });
        // Build fetch.
        const headerInit = {
            'x-riot-token': apiKey,
        };
        const fetchConfig = {
            method: sp.method,
            headers: headerInit,
        };
        if (kwargs.body) {
            fetchConfig.body = JSON.stringify(kwargs.body);
            headerInit['Content-Type'] = 'application/json';
        }
        // Build rateLimitId.
        const rateLimitId = `${strHash(apiKey)}:${regionStr}`;
        // Build methodId.
        const methodId = `${endpoint}:${method}`;
        return this.reqInternal(rateLimitId, methodId, url.href, fetchConfig);
    }
    reqInternal(rateLimitId, methodId, url, fetchConfig) {
        const requester = this._requesters[rateLimitId] || (this._requesters[rateLimitId] = new RegionalRequester(this.config));
        return requester.req(methodId, url, fetchConfig);
    }
    setDistFactor(factor) {
        if (factor <= 0 || 1 < factor)
            throw new Error("Factor must be greater than zero and non-greater than one.");
        if (this.config.distFactor === factor)
            return;
        this.config.distFactor = factor;
        Object.values(this._requesters).forEach(r => r.updateDistFactor());
    }
}
module.exports.TeemoApi = TeemoApi;
/** @internal */
function getApiProxyHandler() {
    return {
        get(target, prop, _receiver) {
            if (prop in target.config.endpoints)
                return new Proxy({ base: target, endpoint: prop }, getApiEndpointProxyHandler());
            if ('base' === prop)
                return target;
            return undefined;
        }
    };
}
/** @internal */
function getApiEndpointProxyHandler() {
    return {
        get(target, prop, _receiver) {
            if (prop in target.base.config.endpoints[target.endpoint])
                return (region, ...kwargs) => target.base.req(target.endpoint, prop, region, ...kwargs);
            return undefined;
        }
    };
}
/** Regional routing values for `tftMatchV1`, `lorRankedV1`, and `AMERICAS` for league endpoints. */
var RegionalRoute;
(function (RegionalRoute) {
    /** Americas. */
    RegionalRoute[RegionalRoute["AMERICAS"] = 1] = "AMERICAS";
    /** Asia. */
    RegionalRoute[RegionalRoute["ASIA"] = 2] = "ASIA";
    /** Europe. */
    RegionalRoute[RegionalRoute["EUROPE"] = 3] = "EUROPE";
    /** South East Asia. Only usable with the LoR endpoints (just `lorRankedV1` for now). */
    RegionalRoute[RegionalRoute["SEA"] = 4] = "SEA";
})(RegionalRoute || (RegionalRoute = {}));
/** Platform routing values for LoL, TFT. */
var PlatformRoute;
(function (PlatformRoute) {
    /** Brazil. */
    PlatformRoute[PlatformRoute["BR1"] = 16] = "BR1";
    /** Europe, Northeast. */
    PlatformRoute[PlatformRoute["EUN1"] = 17] = "EUN1";
    /** Europe, West. */
    PlatformRoute[PlatformRoute["EUW1"] = 18] = "EUW1";
    /** Japan. */
    PlatformRoute[PlatformRoute["JP1"] = 19] = "JP1";
    /** Korea. */
    PlatformRoute[PlatformRoute["KR"] = 20] = "KR";
    /** Latin America, North. */
    PlatformRoute[PlatformRoute["LA1"] = 21] = "LA1";
    /** Latin America, South. */
    PlatformRoute[PlatformRoute["LA2"] = 22] = "LA2";
    /** North America. */
    PlatformRoute[PlatformRoute["NA1"] = 23] = "NA1";
    /** Oceana. */
    PlatformRoute[PlatformRoute["OC1"] = 24] = "OC1";
    /** Rusia. */
    PlatformRoute[PlatformRoute["RU"] = 25] = "RU";
    /** Turkey. */
    PlatformRoute[PlatformRoute["TR1"] = 26] = "TR1";
    /** Public Bet Environment. Only usable with `lolStatusV3`. */
    PlatformRoute[PlatformRoute["PBE1"] = 31] = "PBE1";
})(PlatformRoute || (PlatformRoute = {}));
/** Valorant platform routing values. */
var ValPlatformRoute;
(function (ValPlatformRoute) {
    /** Asia Pacific. */
    ValPlatformRoute[ValPlatformRoute["AP"] = 64] = "AP";
    /** Brazil. */
    ValPlatformRoute[ValPlatformRoute["BR"] = 65] = "BR";
    /** Europe. */
    ValPlatformRoute[ValPlatformRoute["EU"] = 66] = "EU";
    /** Korea. */
    ValPlatformRoute[ValPlatformRoute["KR"] = 67] = "KR";
    /** Latin America. */
    ValPlatformRoute[ValPlatformRoute["LATAM"] = 68] = "LATAM";
    /** North America. */
    ValPlatformRoute[ValPlatformRoute["NA"] = 69] = "NA";
})(ValPlatformRoute || (ValPlatformRoute = {}));
/** Combined routing enum. */
const AnyRoute = Object.assign(Object.assign(Object.assign({}, RegionalRoute), PlatformRoute), ValPlatformRoute);
/** RegionalRoute static utility functions. */
(function (RegionalRoute) {
    function parse(str, excludeSea = false) {
        switch (str.slice(0, 2).toUpperCase()) {
            case "AM": return RegionalRoute.AMERICAS;
            case "AS": return RegionalRoute.ASIA;
            case "EU": return RegionalRoute.EUROPE;
            case "SE": if (!excludeSea)
                return RegionalRoute.SEA;
        }
        throw new Error(`Failed to parse string as RegionalRoute: "${str}" (exclude SEA: ${excludeSea}).`);
    }
    RegionalRoute.parse = parse;
})(RegionalRoute || (RegionalRoute = {}));
/** PlatformRoute static utility functions. */
(function (PlatformRoute) {
    const PLATFORM_TO_REGIONAL = {
        [PlatformRoute.BR1]: RegionalRoute.AMERICAS,
        [PlatformRoute.EUN1]: RegionalRoute.EUROPE,
        [PlatformRoute.EUW1]: RegionalRoute.EUROPE,
        [PlatformRoute.JP1]: RegionalRoute.ASIA,
        [PlatformRoute.KR]: RegionalRoute.ASIA,
        [PlatformRoute.LA1]: RegionalRoute.AMERICAS,
        [PlatformRoute.LA2]: RegionalRoute.AMERICAS,
        [PlatformRoute.NA1]: RegionalRoute.AMERICAS,
        [PlatformRoute.OC1]: RegionalRoute.AMERICAS,
        [PlatformRoute.TR1]: RegionalRoute.EUROPE,
        [PlatformRoute.RU]: RegionalRoute.EUROPE,
        [PlatformRoute.PBE1]: RegionalRoute.AMERICAS,
    };
    /**
     * Converts a PlatformRoute to the corresponding RegionalRoute.
     * Useful for `tftMatchV1` endpoints which require a RegionalRoute, while
     * other TFT endpoints require a PlatformRoute.
     * @param route PlatformRoute to be converted.
     * @returns A RegionalRoute: `AMERICAS`, `ASIA`, or `EUROPE`. Will not
     * return `SEA`, which is only used by `lorRankedV1`.
     */
    function toRegional(route) {
        return PLATFORM_TO_REGIONAL[route];
    }
    PlatformRoute.toRegional = toRegional;
    /**
     * Parse a PlatformRoute from a string, or throw if unparsable.
     * Case-insensitive. Only looks at the beginning two or three-letter
     * prefix to determine the PlatformRoute.
     * @param str String to parse.
     * @returns The parsed PlatformRoute.
     * @throws Error if `str` could not be parsed.
     */
    function parse(str) {
        switch (str.slice(0, 2).toUpperCase()) {
            case "BR": return PlatformRoute.BR1;
            case "JP": return PlatformRoute.JP1;
            case "KR": return PlatformRoute.KR;
            case "NA": return PlatformRoute.NA1;
            case "OC": return PlatformRoute.OC1;
            case "TR": return PlatformRoute.TR1;
            case "RU": return PlatformRoute.RU;
        }
        switch (str.slice(0, 3).toUpperCase()) {
            case "EUN": return PlatformRoute.EUN1;
            case "EUW": return PlatformRoute.EUN1;
            case "LAN":
            case "LA1": return PlatformRoute.LA1;
            case "LAS":
            case "LA2": return PlatformRoute.LA2;
        }
        throw new Error(`Failed to parse string as PlatformRoute: "${str}".`);
    }
    PlatformRoute.parse = parse;
})(PlatformRoute || (PlatformRoute = {}));
/** ValPlatformRoute static utility functions. */
(function (ValPlatformRoute) {
    /**
     * Parse a ValPlatformRoute from a string, or throw if unparsable.
     * Case-insensitive. Only looks at the beginning two-letter prefix to
     * determine the PlatformRoute.
     * @param str String to parse.
     * @returns The parsed ValPlatformRoute.
     * @throws Error if `str` could not be parsed.
     */
    function parse(str) {
        switch (str.slice(0, 2).toUpperCase()) {
            case "AP": return ValPlatformRoute.AP;
            case "BR": return ValPlatformRoute.BR;
            case "EU": return ValPlatformRoute.EU;
            case "KR": return ValPlatformRoute.KR;
            case "LA": return ValPlatformRoute.LATAM;
            case "NA": return ValPlatformRoute.NA;
        }
        throw new Error(`Failed to parse string as ValPlatformRoute: "${str}".`);
    }
    ValPlatformRoute.parse = parse;
})(ValPlatformRoute || (ValPlatformRoute = {}));
Object.assign(module.exports, { RegionalRoute, PlatformRoute, ValPlatformRoute, AnyRoute });
///////////////////////////////////////////////
//                                           //
//                     !                     //
//   This file is automatically generated!   //
//           Do not directly edit!           //
//                                           //
///////////////////////////////////////////////
// http://www.mingweisamuel.com/riotapi-schema/tool/
// Version 570eb12bfe9fb09e435976cb454f622293d0020e
const RiotApiConfig = {
    apiKeys: {
        default: null,
    },
    distFactor: 1.0,
    retries: 3,
    origin: "https://{}.api.riotgames.com",
    defaultBuckets: [
        {
            timespan: 1000,
            limit: 1,
            bins: 1,
            binFactor: 1,
            overhead: 0,
        },
    ],
    rateLimitTypeApplication: {
        name: "application",
        headerLimit: "x-app-rate-limit",
        headerCount: "x-app-rate-limit-count",
    },
    rateLimitTypeMethod: {
        name: "method",
        headerLimit: "x-method-rate-limit",
        headerCount: "x-method-rate-limit-count",
    },
    maxConcurrent: 500,
    headerLimitType: "x-rate-limit-type",
    headerRetryAfter: "retry-after",
    bucketsConfig: {},
    endpoints: {
        accountV1: {
            /**
             * Get account by puuid
             */
            getByPuuid: {
                path: "/riot/account/v1/accounts/by-puuid/{puuid}",
            },
            /**
             * Get account by riot id
             */
            getByRiotId: {
                path: "/riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine}",
            },
            /**
             * Get account by access token
             */
            getByAccessToken: {
                path: "/riot/account/v1/accounts/me",
            },
            /**
             * Get active shard for a player
             */
            getActiveShard: {
                path: "/riot/account/v1/active-shards/by-game/{game}/by-puuid/{puuid}",
            },
        },
        championMasteryV4: {
            /**
             * Get all champion mastery entries sorted by number of champion points descending,
             */
            getAllChampionMasteries: {
                path: "/lol/champion-mastery/v4/champion-masteries/by-summoner/{encryptedSummonerId}",
            },
            /**
             * Get a champion mastery by player ID and champion ID.
             */
            getChampionMastery: {
                path: "/lol/champion-mastery/v4/champion-masteries/by-summoner/{encryptedSummonerId}/by-champion/{championId}",
            },
            /**
             * Get a player's total champion mastery score, which is the sum of individual champion mastery levels.
             */
            getChampionMasteryScore: {
                path: "/lol/champion-mastery/v4/scores/by-summoner/{encryptedSummonerId}",
            },
        },
        championV3: {
            /**
             * Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)
             */
            getChampionInfo: {
                path: "/lol/platform/v3/champion-rotations",
            },
        },
        clashV1: {
            /**
             * Get players by summoner ID.
             * ## Implementation Notes
             * This endpoint returns a list of active Clash players for a given summoner ID. If a summoner registers for multiple tournaments at the same time (e.g., Saturday and Sunday) then both registrations would appear in this list.
             */
            getPlayersBySummoner: {
                path: "/lol/clash/v1/players/by-summoner/{summonerId}",
            },
            /**
             * Get team by ID.
             */
            getTeamById: {
                path: "/lol/clash/v1/teams/{teamId}",
            },
            /**
             * Get all active or upcoming tournaments.
             */
            getTournaments: {
                path: "/lol/clash/v1/tournaments",
            },
            /**
             * Get tournament by team ID.
             */
            getTournamentByTeam: {
                path: "/lol/clash/v1/tournaments/by-team/{teamId}",
            },
            /**
             * Get tournament by ID.
             */
            getTournamentById: {
                path: "/lol/clash/v1/tournaments/{tournamentId}",
            },
        },
        leagueExpV4: {
            /**
             * Get all the league entries.
             */
            getLeagueEntries: {
                path: "/lol/league-exp/v4/entries/{queue}/{tier}/{division}",
            },
        },
        leagueV4: {
            /**
             * Get the challenger league for given queue.
             */
            getChallengerLeague: {
                path: "/lol/league/v4/challengerleagues/by-queue/{queue}",
            },
            /**
             * Get league entries in all queues for a given summoner ID.
             */
            getLeagueEntriesForSummoner: {
                path: "/lol/league/v4/entries/by-summoner/{encryptedSummonerId}",
            },
            /**
             * Get all the league entries.
             */
            getLeagueEntries: {
                path: "/lol/league/v4/entries/{queue}/{tier}/{division}",
            },
            /**
             * Get the grandmaster league of a specific queue.
             */
            getGrandmasterLeague: {
                path: "/lol/league/v4/grandmasterleagues/by-queue/{queue}",
            },
            /**
             * Get league with given ID, including inactive entries.
             */
            getLeagueById: {
                path: "/lol/league/v4/leagues/{leagueId}",
            },
            /**
             * Get the master league for given queue.
             */
            getMasterLeague: {
                path: "/lol/league/v4/masterleagues/by-queue/{queue}",
            },
        },
        lolStatusV3: {
            /**
             * Get League of Legends status for the given shard.
             * ## Rate Limit Notes
             * Requests to this API are not counted against the application Rate Limits.
             */
            getShardData: {
                path: "/lol/status/v3/shard-data",
            },
        },
        lolStatusV4: {
            /**
             * Get League of Legends status for the given platform.
             */
            getPlatformData: {
                path: "/lol/status/v4/platform-data",
            },
        },
        lorDeckV1: {
            /**
             * Get a list of the calling user's decks.
             */
            getDecks: {
                path: "/lor/deck/v1/decks/me",
                apiKeyName: "lor",
            },
            /**
             * Create a new deck for the calling user.
             */
            createDeck: {
                path: "/lor/deck/v1/decks/me",
                method: "post",
                apiKeyName: "lor",
            },
        },
        lorInventoryV1: {
            /**
             * Return a list of cards owned by the calling user.
             */
            getCards: {
                path: "/lor/inventory/v1/cards/me",
                apiKeyName: "lor",
            },
        },
        lorMatchV1: {
            /**
             * Get a list of match ids by PUUID
             */
            getMatchIdsByPUUID: {
                path: "/lor/match/v1/matches/by-puuid/{puuid}/ids",
                apiKeyName: "lor",
            },
            /**
             * Get match by id
             */
            getMatch: {
                path: "/lor/match/v1/matches/{matchId}",
                apiKeyName: "lor",
            },
        },
        lorRankedV1: {
            /**
             * Get the players in Master tier.
             */
            getLeaderboards: {
                path: "/lor/ranked/v1/leaderboards",
                apiKeyName: "lor",
            },
        },
        lorStatusV1: {
            /**
             * Get Legends of Runeterra status for the given platform.
             */
            getPlatformData: {
                path: "/lor/status/v1/platform-data",
                apiKeyName: "lor",
            },
        },
        matchV4: {
            /**
             * Get match IDs by tournament code.
             */
            getMatchIdsByTournamentCode: {
                path: "/lol/match/v4/matches/by-tournament-code/{tournamentCode}/ids",
            },
            /**
             * Get match by match ID.
             */
            getMatch: {
                path: "/lol/match/v4/matches/{matchId}",
            },
            /**
             * Get match by match ID and tournament code.
             */
            getMatchByTournamentCode: {
                path: "/lol/match/v4/matches/{matchId}/by-tournament-code/{tournamentCode}",
            },
            /**
             * Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.
             * ## Implementation Notes
             * A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.
             *
             * If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.
             *
             * If beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
             */
            getMatchlist: {
                path: "/lol/match/v4/matchlists/by-account/{encryptedAccountId}",
            },
            /**
             * Get match timeline by match ID.
             * ## Implementation Notes
             * Not all matches have timeline data.
             */
            getMatchTimeline: {
                path: "/lol/match/v4/timelines/by-match/{matchId}",
            },
        },
        matchV5: {
            /**
             * Get a list of match ids by puuid
             */
            getMatchIdsByPUUID: {
                path: "/lol/match/v5/matches/by-puuid/{puuid}/ids",
            },
            /**
             * Get a match by match id
             */
            getMatch: {
                path: "/lol/match/v5/matches/{matchId}",
            },
            /**
             * Get a match timeline by match id
             */
            getTimeline: {
                path: "/lol/match/v5/matches/{matchId}/timeline",
            },
        },
        spectatorV4: {
            /**
             * Get current game information for the given summoner ID.
             */
            getCurrentGameInfoBySummoner: {
                path: "/lol/spectator/v4/active-games/by-summoner/{encryptedSummonerId}",
            },
            /**
             * Get list of featured games.
             */
            getFeaturedGames: {
                path: "/lol/spectator/v4/featured-games",
            },
        },
        summonerV4: {
            /**
             * Get a summoner by account ID.
             */
            getByAccountId: {
                path: "/lol/summoner/v4/summoners/by-account/{encryptedAccountId}",
            },
            /**
             * Get a summoner by summoner name.
             */
            getBySummonerName: {
                path: "/lol/summoner/v4/summoners/by-name/{summonerName}",
            },
            /**
             * Get a summoner by PUUID.
             */
            getByPUUID: {
                path: "/lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}",
            },
            /**
             * Get a summoner by access token.
             */
            getByAccessToken: {
                path: "/lol/summoner/v4/summoners/me",
            },
            /**
             * Get a summoner by summoner ID.
             */
            getBySummonerId: {
                path: "/lol/summoner/v4/summoners/{encryptedSummonerId}",
            },
        },
        tftLeagueV1: {
            /**
             * Get the challenger league.
             */
            getChallengerLeague: {
                path: "/tft/league/v1/challenger",
                apiKeyName: "tft",
            },
            /**
             * Get league entries for a given summoner ID.
             */
            getLeagueEntriesForSummoner: {
                path: "/tft/league/v1/entries/by-summoner/{summonerId}",
                apiKeyName: "tft",
            },
            /**
             * Get all the league entries.
             */
            getLeagueEntries: {
                path: "/tft/league/v1/entries/{tier}/{division}",
                apiKeyName: "tft",
            },
            /**
             * Get the grandmaster league.
             */
            getGrandmasterLeague: {
                path: "/tft/league/v1/grandmaster",
                apiKeyName: "tft",
            },
            /**
             * Get league with given ID, including inactive entries.
             */
            getLeagueById: {
                path: "/tft/league/v1/leagues/{leagueId}",
                apiKeyName: "tft",
            },
            /**
             * Get the master league.
             */
            getMasterLeague: {
                path: "/tft/league/v1/master",
                apiKeyName: "tft",
            },
            /**
             * Get the top rated ladder for given queue
             */
            getTopRatedLadder: {
                path: "/tft/league/v1/rated-ladders/{queue}/top",
                apiKeyName: "tft",
            },
        },
        tftMatchV1: {
            /**
             * Get a list of match ids by PUUID
             */
            getMatchIdsByPUUID: {
                path: "/tft/match/v1/matches/by-puuid/{puuid}/ids",
                apiKeyName: "tft",
            },
            /**
             * Get a match by match id
             */
            getMatch: {
                path: "/tft/match/v1/matches/{matchId}",
                apiKeyName: "tft",
            },
        },
        tftSummonerV1: {
            /**
             * Get a summoner by account ID.
             */
            getByAccountId: {
                path: "/tft/summoner/v1/summoners/by-account/{encryptedAccountId}",
                apiKeyName: "tft",
            },
            /**
             * Get a summoner by summoner name.
             */
            getBySummonerName: {
                path: "/tft/summoner/v1/summoners/by-name/{summonerName}",
                apiKeyName: "tft",
            },
            /**
             * Get a summoner by PUUID.
             */
            getByPUUID: {
                path: "/tft/summoner/v1/summoners/by-puuid/{encryptedPUUID}",
                apiKeyName: "tft",
            },
            /**
             * Get a summoner by access token.
             */
            getByAccessToken: {
                path: "/tft/summoner/v1/summoners/me",
                apiKeyName: "tft",
            },
            /**
             * Get a summoner by summoner ID.
             */
            getBySummonerId: {
                path: "/tft/summoner/v1/summoners/{encryptedSummonerId}",
                apiKeyName: "tft",
            },
        },
        thirdPartyCodeV4: {
            /**
             * Get third party code for a given summoner ID.
             */
            getThirdPartyCodeBySummonerId: {
                path: "/lol/platform/v4/third-party-code/by-summoner/{encryptedSummonerId}",
            },
        },
        tournamentStubV4: {
            /**
             * Create a mock tournament code for the given tournament.
             */
            createTournamentCode: {
                path: "/lol/tournament-stub/v4/codes",
                method: "post",
                apiKeyName: "tournament",
            },
            /**
             * Gets a mock list of lobby events by tournament code.
             */
            getLobbyEventsByCode: {
                path: "/lol/tournament-stub/v4/lobby-events/by-code/{tournamentCode}",
                apiKeyName: "tournament",
            },
            /**
             * Creates a mock tournament provider and returns its ID.
             * ## Implementation Notes
             * Providers will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
             */
            registerProviderData: {
                path: "/lol/tournament-stub/v4/providers",
                method: "post",
                apiKeyName: "tournament",
            },
            /**
             * Creates a mock tournament and returns its ID.
             */
            registerTournament: {
                path: "/lol/tournament-stub/v4/tournaments",
                method: "post",
                apiKeyName: "tournament",
            },
        },
        tournamentV4: {
            /**
             * Create a tournament code for the given tournament.
             */
            createTournamentCode: {
                path: "/lol/tournament/v4/codes",
                method: "post",
                apiKeyName: "tournament",
            },
            /**
             * Returns the tournament code DTO associated with a tournament code string.
             */
            getTournamentCode: {
                path: "/lol/tournament/v4/codes/{tournamentCode}",
                apiKeyName: "tournament",
            },
            /**
             * Update the pick type, map, spectator type, or allowed summoners for a code.
             */
            updateCode: {
                path: "/lol/tournament/v4/codes/{tournamentCode}",
                method: "put",
                apiKeyName: "tournament",
            },
            /**
             * Gets a list of lobby events by tournament code.
             */
            getLobbyEventsByCode: {
                path: "/lol/tournament/v4/lobby-events/by-code/{tournamentCode}",
                apiKeyName: "tournament",
            },
            /**
             * Creates a tournament provider and returns its ID.
             * ## Implementation Notes
             * Providers will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
             */
            registerProviderData: {
                path: "/lol/tournament/v4/providers",
                method: "post",
                apiKeyName: "tournament",
            },
            /**
             * Creates a tournament and returns its ID.
             */
            registerTournament: {
                path: "/lol/tournament/v4/tournaments",
                method: "post",
                apiKeyName: "tournament",
            },
        },
        valContentV1: {
            /**
             * Get content optionally filtered by locale
             */
            getContent: {
                path: "/val/content/v1/contents",
            },
        },
        valMatchV1: {
            /**
             * Get match by id
             */
            getMatch: {
                path: "/val/match/v1/matches/{matchId}",
            },
            /**
             * Get matchlist for games played by puuid
             */
            getMatchlist: {
                path: "/val/match/v1/matchlists/by-puuid/{puuid}",
            },
            /**
             * Get recent matches
             * ## Implementation Notes
             * Returns a list of match ids that have completed in the last 10 minutes for live regions and 12 hours for the esports routing value. NA/LATAM/BR share a match history deployment. As such, recent matches will return a combined list of matches from those three regions. Requests are load balanced so you may see some inconsistencies as matches are added/removed from the list.
             */
            getRecent: {
                path: "/val/match/v1/recent-matches/by-queue/{queue}",
            },
        },
        valRankedV1: {
            /**
             * Get leaderboard for the competitive queue
             */
            getLeaderboard: {
                path: "/val/ranked/v1/leaderboards/by-act/{actId}",
            },
        },
        valStatusV1: {
            /**
             * Get VALORANT status for the given platform.
             */
            getPlatformData: {
                path: "/val/status/v1/platform-data",
            },
        },
    },
};
// TODO: other specs.
Object.assign(module.exports, { RiotApiConfig });
///////////////////////////////////////////////
//                                           //
//                     !                     //
//   This file is automatically generated!   //
//           Do not directly edit!           //
//                                           //
///////////////////////////////////////////////
//# sourceMappingURL=index.js.map